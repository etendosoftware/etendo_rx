---
phase: 03-generic-repository-layer
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - modules_core/com.etendorx.das/src/main/java/com/etendorx/das/repository/EntityClassResolver.java
  - modules_core/com.etendorx.das/src/main/java/com/etendorx/das/repository/DynamicRepositoryException.java
  - modules_core/com.etendorx.das/src/main/java/com/etendorx/das/repository/DynamicRepository.java
autonomous: true

must_haves:
  truths:
    - "Entity classes are resolved from table IDs via Hibernate metamodel at startup"
    - "Any entity can be read by ID and returned as Map<String, Object>"
    - "Any entity can be listed with pagination, sorting, and field filtering"
    - "A new entity can be saved from a Map with correct audit/validation/externalId flow"
    - "An existing entity can be updated from a partial Map preserving unchanged fields"
    - "Batch save processes all entities in a single transaction"
    - "Validation rejects entities with missing mandatory fields but skips id violations"
  artifacts:
    - path: "modules_core/com.etendorx.das/src/main/java/com/etendorx/das/repository/EntityClassResolver.java"
      provides: "Metamodel-based table ID to entity class resolution"
      contains: "getMetamodel"
    - path: "modules_core/com.etendorx.das/src/main/java/com/etendorx/das/repository/DynamicRepositoryException.java"
      provides: "Domain-specific runtime exception for repository errors"
      contains: "class DynamicRepositoryException"
    - path: "modules_core/com.etendorx.das/src/main/java/com/etendorx/das/repository/DynamicRepository.java"
      provides: "Full CRUD + batch + pagination repository"
      contains: "performSaveOrUpdate"
  key_links:
    - from: "DynamicRepository.java"
      to: "DynamicDTOConverter"
      via: "constructor injection"
      pattern: "converter\\.convertToMap|converter\\.convertToEntity"
    - from: "DynamicRepository.java"
      to: "DynamicMetadataService"
      via: "constructor injection"
      pattern: "metadataService\\.getProjectionEntity"
    - from: "DynamicRepository.java"
      to: "EntityClassResolver"
      via: "constructor injection"
      pattern: "entityClassResolver\\.resolveByTableId"
    - from: "DynamicRepository.java"
      to: "RestCallTransactionHandler"
      via: "manual begin/commit for write operations"
      pattern: "transactionHandler\\.begin|transactionHandler\\.commit"
    - from: "DynamicRepository.java"
      to: "ExternalIdService"
      via: "add + flush after entity merge"
      pattern: "externalIdService\\.add|externalIdService\\.flush"
    - from: "EntityClassResolver.java"
      to: "EntityManager.getMetamodel()"
      via: "ApplicationReadyEvent listener"
      pattern: "getMetamodel\\(\\)\\.getEntities"
---

<objective>
Create the complete Generic Repository Layer: EntityClassResolver for metamodel-based class resolution, DynamicRepositoryException for error handling, and DynamicRepository with full CRUD operations (findById, findAll with pagination/filtering, save/update with upsert, batch save) replicating the exact order of operations from BaseDTORepositoryDefault.

Purpose: This is the data access layer that bridges Phase 1 metadata + Phase 2 converter with actual JPA persistence. Without it, the dynamic DAS layer has no way to read or write entities.

Output: Three production classes in `com.etendorx.das.repository` package providing the complete dynamic repository capability.
</objective>

<execution_context>
@/Users/sebastianbarrozo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sebastianbarrozo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-generic-repository-layer/03-RESEARCH.md
@.planning/phases/03-generic-repository-layer/03-CONTEXT.md
@.planning/phases/02-generic-dto-converter/02-02-SUMMARY.md

Key source files to read before implementing:
@modules_core/com.etendorx.das/src/main/java/com/etendorx/das/converter/DynamicDTOConverter.java
@modules_core/com.etendorx.das/src/main/java/com/etendorx/das/metadata/DynamicMetadataService.java
@modules_core/com.etendorx.das/src/main/java/com/etendorx/das/metadata/models/EntityMetadata.java
@modules_core/com.etendorx.das/src/main/java/com/etendorx/das/metadata/models/FieldMetadata.java
@modules_core/com.etendorx.das/src/main/java/com/etendorx/das/metadata/models/FieldMappingType.java
@libs/com.etendorx.das_core/src/main/java/com/etendorx/eventhandler/transaction/RestCallTransactionHandler.java
@libs/com.etendorx.das_core/src/main/java/com/etendorx/entities/mapper/lib/ExternalIdService.java
@libs/com.etendorx.das_core/src/main/java/com/etendorx/entities/mapper/lib/PostSyncService.java

Also read these existing implementations for reference patterns:
- BaseDTORepositoryDefault.java (search for it in modules_core/com.etendorx.das or libs/) for the exact save/update flow
- AuditServiceInterceptorImpl.java for audit field integration
- A generated entity class (search for TABLE_ID static field) to verify @Table annotation + TABLE_ID pattern
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create EntityClassResolver and DynamicRepositoryException</name>
  <files>
    modules_core/com.etendorx.das/src/main/java/com/etendorx/das/repository/EntityClassResolver.java
    modules_core/com.etendorx.das/src/main/java/com/etendorx/das/repository/DynamicRepositoryException.java
  </files>
  <action>
    Create the `com.etendorx.das.repository` package and two foundation classes:

    **DynamicRepositoryException.java** (~20 lines):
    - Extends RuntimeException
    - Two constructors: (String message) and (String message, Throwable cause)
    - Add Apache License header matching project convention

    **EntityClassResolver.java** (~80 lines):
    - @Component, @Slf4j
    - Constructor injects EntityManager
    - Two ConcurrentHashMap fields: `tableNameToClass` (String -> Class) and `tableIdToClass` (String -> Class)
    - `@EventListener(ApplicationReadyEvent.class) public void init()` method that:
      1. Gets `entityManager.getMetamodel().getEntities()`
      2. For each EntityType, gets the javaType
      3. Reads `@jakarta.persistence.Table(name=...)` annotation, puts lowercase into tableNameToClass
      4. Uses reflection to read static `TABLE_ID` field (all generated entities have `public static final String TABLE_ID`), puts into tableIdToClass
      5. Catches NoSuchFieldException/IllegalAccessException for entities without TABLE_ID (not all managed types have it)
      6. Logs number of resolved entities at INFO level
    - `public Class<?> resolveByTableId(String tableId)` returns from tableIdToClass map, throws DynamicRepositoryException if not found
    - `public Class<?> resolveByTableName(String tableName)` returns from tableNameToClass map (lowercase), throws DynamicRepositoryException if not found

    IMPORTANT: Use @EventListener(ApplicationReadyEvent.class) NOT @PostConstruct (Phase 1 established this pattern). Import from org.springframework.boot.context.event.ApplicationReadyEvent.
  </action>
  <verify>
    Files compile syntactically (check for import completeness). Verify:
    - `grep -r "TABLE_ID" EntityClassResolver.java` confirms TABLE_ID field access pattern
    - `grep -r "getMetamodel" EntityClassResolver.java` confirms metamodel usage
    - `grep -r "ApplicationReadyEvent" EntityClassResolver.java` confirms startup pattern
  </verify>
  <done>
    EntityClassResolver resolves entity classes by both table ID and table name using Hibernate metamodel. DynamicRepositoryException provides clean exception hierarchy.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create DynamicRepository with full CRUD, batch, pagination, and validation</name>
  <files>
    modules_core/com.etendorx.das/src/main/java/com/etendorx/das/repository/DynamicRepository.java
  </files>
  <action>
    Create DynamicRepository.java (~300 lines) in `com.etendorx.das.repository` package:

    **Class structure:**
    - @Component, @Slf4j
    - Constructor injection of ALL dependencies:
      - EntityManager entityManager
      - DynamicDTOConverter converter
      - DynamicMetadataService metadataService
      - AuditServiceInterceptor auditService
      - RestCallTransactionHandler transactionHandler
      - ExternalIdService externalIdService
      - PostSyncService postSyncService
      - Validator validator (jakarta.validation.Validator)
      - EntityClassResolver entityClassResolver
      - Optional<DefaultValuesHandler> defaultValuesHandler (inject as Optional for safety -- may not exist)
    - Note: Check if DefaultValuesHandler interface exists in codebase. If not found, omit it and add a TODO comment.

    **READ OPERATIONS (annotated with @Transactional):**

    1. `findById(String id, String projectionName, String entityName) -> Map<String, Object>`:
       - Resolve EntityMetadata via metadataService.getProjectionEntity(projectionName, entityName)
       - Throw DynamicRepositoryException if not found
       - Resolve entity class via entityClassResolver.resolveByTableId(entityMeta.tableId())
       - Call entityManager.find(entityClass, id)
       - Throw jakarta.persistence.EntityNotFoundException if entity is null (message: "Entity {entityName} not found with id: {id}")
       - Return converter.convertToMap(entity, entityMeta)

    2. `findAll(String projectionName, String entityName, Map<String, String> filters, Pageable pageable) -> Page<Map<String, Object>>`:
       - Resolve EntityMetadata and entity class (same as findById)
       - Use CriteriaBuilder for dynamic query construction:
         a. Create count query: CriteriaQuery<Long>, cb.count(countRoot), apply predicates, get total
         b. Create data query: CriteriaQuery with entityClass, apply predicates
         c. Apply sorting from pageable.getSort() using cb.asc/cb.desc
         d. Set pagination: typedQuery.setFirstResult((int) pageable.getOffset()), setMaxResults(pageable.getPageSize())
         e. Execute query, convert each result via converter.convertToMap()
         f. Return new PageImpl<>(converted, pageable, total)
       - Private helper `buildPredicates(CriteriaBuilder cb, Root<?> root, Map<String, String> filters, List<FieldMetadata> fields)`:
         - For each filter entry, find matching FieldMetadata where f.name().equals(filterKey) AND f.fieldMapping() == FieldMappingType.DIRECT_MAPPING
         - If found, build Path using field.property() (split by "." for nested paths)
         - Add cb.equal(path, value) predicate
         - ONLY support DIRECT_MAPPING fields for filtering (other types don't have entity properties)
       - Private helper `buildPath(Root<?> root, String propertyPath)`:
         - Split by ".", iterate parts, chain path.get(part)

    **WRITE OPERATIONS (NOT annotated with @Transactional -- use manual transactionHandler):**

    3. `save(Map<String, Object> dto, String projectionName, String entityName) -> Map<String, Object>`:
       - Delegates to performSaveOrUpdate(dto, entityMeta, true /*isNew*/)

    4. `update(Map<String, Object> dto, String projectionName, String entityName) -> Map<String, Object>`:
       - Delegates to performSaveOrUpdate(dto, entityMeta, false /*isNew*/)

    5. `saveBatch(List<Map<String, Object>> dtos, String projectionName, String entityName) -> List<Map<String, Object>>`:
       - Resolve EntityMetadata once
       - Call transactionHandler.begin() once
       - Iterate dtos, call performSaveOrUpdateInternal for each (within same transaction)
       - Call transactionHandler.commit() after all
       - On exception: let it propagate (transaction rollback is automatic)
       - Return list of results

    6. `private performSaveOrUpdate(Map<String, Object> dto, EntityMetadata entityMeta, boolean isNew) -> Map<String, Object>`:
       - Wraps performSaveOrUpdateInternal with its own begin/commit:
       ```
       try {
           transactionHandler.begin();
           Map<String, Object> result = performSaveOrUpdateInternal(dto, entityMeta, isNew);
           transactionHandler.commit();
           return result;
       } catch (ResponseStatusException e) {
           throw e;
       } catch (Exception e) {
           throw new ResponseStatusException(HttpStatus.INTERNAL_SERVER_ERROR, e.getMessage(), e);
       }
       ```

    7. `private performSaveOrUpdateInternal(Map<String, Object> dto, EntityMetadata entityMeta, boolean isNewParam) -> Map<String, Object>`:
       REPLICATE EXACT ORDER from BaseDTORepositoryDefault (documented in 03-RESEARCH.md Pattern 3):
       ```
       boolean isNew = isNewParam;
       Class<?> entityClass = entityClassResolver.resolveByTableId(entityMeta.tableId());
       Object existingEntity = null;
       String dtoId = (String) dto.get("id");

       // Upsert: check existence when ID provided
       if (dtoId != null) {
           existingEntity = entityManager.find(entityClass, dtoId);
           if (existingEntity != null) {
               isNew = false;
           }
       }

       // Convert DTO to entity
       Object entity = converter.convertToEntity(dto, existingEntity, entityMeta, entityMeta.fields());

       // Default values (if handler exists)
       // defaultValuesHandler.ifPresent(h -> h.setDefaultValues(entity));

       // Audit values
       if (entity instanceof BaseRXObject rxObj) {
           auditService.setAuditValues(rxObj);
       }

       // Validate (skip "id" violations)
       validateEntity(entity);

       // First save
       entity = entityManager.merge(entity);
       entityManager.flush();

       // External ID registration (AFTER merge so entity has ID)
       String tableId = entityMeta.tableId();
       externalIdService.add(tableId, dtoId, entity);
       externalIdService.flush();

       // Second save (after potential list processing)
       entity = entityManager.merge(entity);
       postSyncService.flush();
       externalIdService.flush();

       // Return freshly read result
       String newId = getEntityId(entity);
       Object freshEntity = entityManager.find(entityClass, newId);
       return converter.convertToMap(freshEntity, entityMeta);
       ```

    **HELPER METHODS:**

    8. `private validateEntity(Object entity)`:
       - Call validator.validate(entity)
       - Build list of violation messages, SKIP violations where propertyPath equals "id" (use StringUtils.equals or Objects.equals)
       - If violations remain, throw ResponseStatusException(HttpStatus.BAD_REQUEST, "Validation failed: " + messages)
       - Import org.springframework.web.server.ResponseStatusException and org.springframework.http.HttpStatus

    9. `private getEntityId(Object entity)`:
       - Use PropertyUtils.getProperty(entity, "id") from Apache Commons BeanUtils (already on classpath from Phase 2)
       - Cast to String and return
       - Wrap in try/catch, throw DynamicRepositoryException on failure

    **CRITICAL NOTES (from RESEARCH.md pitfalls):**
    - Write methods MUST NOT be annotated with @Transactional (transactionHandler.commit() uses REQUIRES_NEW)
    - Always use entityManager.merge() (not persist()) -- handles both new and existing entities
    - Call externalIdService.add() AFTER first merge (entity needs ID)
    - Call externalIdService.flush() TWICE (after first save and after second save)
    - Skip "id" in validation violations (entities have @NotNull on id field but JPA generates it)
    - Use ResponseStatusException for error responses (matches existing pattern)
  </action>
  <verify>
    Verify the file structure:
    - `grep -c "transactionHandler.begin\|transactionHandler.commit" DynamicRepository.java` should show begin/commit pairs
    - `grep -c "externalIdService.flush" DynamicRepository.java` should show at least 2 flush calls
    - `grep -c "@Transactional" DynamicRepository.java` should show it ONLY on read methods (findById, findAll)
    - `grep "entityManager.merge" DynamicRepository.java` should show merge (not persist)
    - `grep "violation.getPropertyPath.*id" DynamicRepository.java` should confirm id skip in validation
  </verify>
  <done>
    DynamicRepository provides complete CRUD + batch + pagination with correct transaction handling matching BaseDTORepositoryDefault behavior. EntityManager.merge() used for persistence, externalIdService called twice, validation skips "id" property, write methods use manual transactionHandler (not @Transactional).
  </done>
</task>

</tasks>

<verification>
After both tasks complete, verify:
1. All three files exist in `com.etendorx.das.repository` package
2. EntityClassResolver uses @EventListener(ApplicationReadyEvent.class) for initialization
3. DynamicRepository has constructor injection for all 9-10 dependencies
4. Read operations have @Transactional, write operations do NOT
5. performSaveOrUpdateInternal follows the exact 14-step sequence from research
6. No circular dependencies (DynamicRepository depends on Phase 1 + Phase 2 components, not vice versa)
7. Import statements reference correct packages (com.etendorx.das.converter.DynamicDTOConverter, com.etendorx.das.metadata.DynamicMetadataService, etc.)
</verification>

<success_criteria>
- EntityClassResolver scans Hibernate metamodel at startup and resolves entity classes by table ID and table name
- DynamicRepository.findById resolves metadata -> resolves class -> finds entity -> converts to Map
- DynamicRepository.findAll uses CriteriaBuilder for filtering + pagination, returns Page<Map>
- DynamicRepository.save/update replicates BaseDTORepositoryDefault.performSaveOrUpdate exact flow
- DynamicRepository.saveBatch wraps all entities in single transactionHandler.begin/commit
- Validation skips "id" violations, throws ResponseStatusException(BAD_REQUEST)
- No @Transactional on write methods, @Transactional on read methods
</success_criteria>

<output>
After completion, create `.planning/phases/03-generic-repository-layer/03-01-SUMMARY.md`
</output>
