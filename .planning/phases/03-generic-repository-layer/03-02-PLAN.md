---
phase: 03-generic-repository-layer
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - modules_core/com.etendorx.das/src/test/java/com/etendorx/das/unit/repository/EntityClassResolverTest.java
  - modules_core/com.etendorx.das/src/test/java/com/etendorx/das/unit/repository/DynamicRepositoryTest.java
autonomous: true

must_haves:
  truths:
    - "EntityClassResolver correctly maps TABLE_ID to entity classes"
    - "EntityClassResolver correctly maps table names to entity classes"
    - "EntityClassResolver throws when table ID is not found"
    - "DynamicRepository.findById returns converted Map for existing entity"
    - "DynamicRepository.findById throws EntityNotFoundException for missing entity"
    - "DynamicRepository.findAll returns paginated results with correct total"
    - "DynamicRepository.save follows exact order: merge -> externalId.add -> flush -> merge -> postSync.flush -> externalId.flush"
    - "DynamicRepository.save calls auditService for BaseRXObject entities"
    - "DynamicRepository.saveBatch wraps all entities in single begin/commit"
    - "DynamicRepository validation skips id property violations"
  artifacts:
    - path: "modules_core/com.etendorx.das/src/test/java/com/etendorx/das/unit/repository/EntityClassResolverTest.java"
      provides: "Unit tests for metamodel-based entity class resolution"
      min_lines: 80
    - path: "modules_core/com.etendorx.das/src/test/java/com/etendorx/das/unit/repository/DynamicRepositoryTest.java"
      provides: "Unit tests for CRUD, batch, pagination, and validation"
      min_lines: 200
  key_links:
    - from: "EntityClassResolverTest.java"
      to: "EntityClassResolver"
      via: "direct instantiation with mocked EntityManager"
      pattern: "EntityClassResolver"
    - from: "DynamicRepositoryTest.java"
      to: "DynamicRepository"
      via: "manual constructor with all mocked dependencies"
      pattern: "DynamicRepository"
    - from: "DynamicRepositoryTest.java"
      to: "verify.*transactionHandler"
      via: "Mockito verify for transaction order"
      pattern: "verify.*begin|verify.*commit"
---

<objective>
Create comprehensive unit tests for the Generic Repository Layer: EntityClassResolver metamodel resolution tests and DynamicRepository CRUD/batch/pagination/validation tests.

Purpose: Verify correct behavior of all repository operations, especially the critical transaction orchestration flow that must match BaseDTORepositoryDefault exactly. Tests provide regression safety net for the dynamic repository.

Output: Two test files covering EntityClassResolver and DynamicRepository with ~25-35 tests total.
</objective>

<execution_context>
@/Users/sebastianbarrozo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sebastianbarrozo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-generic-repository-layer/03-RESEARCH.md
@.planning/phases/03-generic-repository-layer/03-01-SUMMARY.md

Key source files to test:
@modules_core/com.etendorx.das/src/main/java/com/etendorx/das/repository/EntityClassResolver.java
@modules_core/com.etendorx.das/src/main/java/com/etendorx/das/repository/DynamicRepository.java
@modules_core/com.etendorx.das/src/main/java/com/etendorx/das/repository/DynamicRepositoryException.java

Reference for test patterns (Phase 2 tests):
@modules_core/com.etendorx.das/src/test/java/com/etendorx/das/unit/converter/DynamicDTOConverterTest.java
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create EntityClassResolver unit tests</name>
  <files>
    modules_core/com.etendorx.das/src/test/java/com/etendorx/das/unit/repository/EntityClassResolverTest.java
  </files>
  <action>
    Create EntityClassResolverTest.java in `com.etendorx.das.unit.repository` package (~100 lines).

    **Test setup:**
    - @ExtendWith(MockitoExtension.class)
    - @Mock EntityManager entityManager
    - @Mock Metamodel metamodel
    - Manual construction of EntityClassResolver in @BeforeEach (inject mocked EntityManager)

    **Helper setup for mocking metamodel:**
    Create a helper method that prepares mock EntityType objects. For each test entity:
    - Mock EntityType with getJavaType() returning a test class
    - The test class should have @jakarta.persistence.Table(name = "test_table") annotation
    - The test class should have a static TABLE_ID field
    - Use inner test classes annotated with @Table for this purpose:
      ```java
      @jakarta.persistence.Table(name = "test_table")
      static class TestEntity {
          public static final String TABLE_ID = "100";
      }

      @jakarta.persistence.Table(name = "another_table")
      static class AnotherEntity {
          public static final String TABLE_ID = "200";
      }

      // Entity without TABLE_ID
      @jakarta.persistence.Table(name = "no_tableid")
      static class NoTableIdEntity {
      }
      ```

    **Tests (~8 tests):**

    1. `init_scansMetamodelAndPopulatesMaps()`:
       - Mock metamodel to return Set of EntityTypes for TestEntity and AnotherEntity
       - Call init()
       - Assert resolveByTableId("100") returns TestEntity.class
       - Assert resolveByTableId("200") returns AnotherEntity.class

    2. `resolveByTableId_returnsCorrectClass()`:
       - Setup metamodel with TestEntity
       - Call init(), then resolveByTableId("100")
       - Assert returns TestEntity.class

    3. `resolveByTableId_throwsWhenNotFound()`:
       - Setup empty or non-matching metamodel
       - Call init()
       - assertThrows(DynamicRepositoryException.class, () -> resolver.resolveByTableId("999"))

    4. `resolveByTableName_returnsCorrectClass()`:
       - Setup metamodel with TestEntity (table name "test_table")
       - Call init(), then resolveByTableName("test_table")
       - Assert returns TestEntity.class

    5. `resolveByTableName_isCaseInsensitive()`:
       - Verify resolveByTableName("TEST_TABLE") also works (annotation value stored lowercase)

    6. `resolveByTableName_throwsWhenNotFound()`:
       - assertThrows(DynamicRepositoryException.class, () -> resolver.resolveByTableName("nonexistent"))

    7. `init_handlesEntityWithoutTableId()`:
       - Include NoTableIdEntity in metamodel (has @Table but no TABLE_ID field)
       - Call init() -- should not throw
       - Assert resolveByTableName("no_tableid") returns NoTableIdEntity.class
       - Assert resolveByTableId with any ID does not return NoTableIdEntity

    8. `init_handlesEntityWithoutTableAnnotation()`:
       - Create an inner entity class WITHOUT @Table annotation
       - Include in metamodel
       - Call init() -- should not throw (gracefully skips)

    **Mocking pattern for EntityManager.getMetamodel():**
    ```java
    when(entityManager.getMetamodel()).thenReturn(metamodel);
    EntityType<?> mockType = mock(EntityType.class);
    when(mockType.getJavaType()).thenReturn((Class) TestEntity.class);
    when(metamodel.getEntities()).thenReturn(Set.of(mockType));
    ```
  </action>
  <verify>
    - File exists at expected path
    - Contains @ExtendWith(MockitoExtension.class)
    - Contains at least 7 @Test methods
    - All test methods follow AAA pattern (Arrange-Act-Assert)
    - Inner test entity classes have @Table annotations
  </verify>
  <done>
    EntityClassResolver has 8 unit tests covering: metamodel scanning, table ID resolution, table name resolution, case insensitivity, not-found exceptions, entities without TABLE_ID, and entities without @Table annotation.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create DynamicRepository unit tests</name>
  <files>
    modules_core/com.etendorx.das/src/test/java/com/etendorx/das/unit/repository/DynamicRepositoryTest.java
  </files>
  <action>
    Create DynamicRepositoryTest.java in `com.etendorx.das.unit.repository` package (~300 lines).

    **Test setup:**
    - @ExtendWith(MockitoExtension.class)
    - @Mock for ALL dependencies: EntityManager, DynamicDTOConverter, DynamicMetadataService, AuditServiceInterceptor, RestCallTransactionHandler, ExternalIdService, PostSyncService, Validator, EntityClassResolver
    - Manual construction of DynamicRepository in @BeforeEach with all mocked dependencies
    - NOTE: DynamicRepository may have Optional<DefaultValuesHandler> -- if so, pass Optional.empty()
    - Helper methods createEntityMetadata() and createFieldMetadata() (same pattern as Phase 2 tests)

    **Inner test classes:**
    ```java
    // Simple POJO for testing entity operations
    static class TestEntity extends BaseRXObject {
        private String id;
        public String getId() { return id; }
        public void setId(String id) { this.id = id; }
        // Minimal BaseRXObject stubs as needed
    }

    // Non-BaseRXObject entity for testing audit skip
    static class PlainEntity {
        private String id;
        public String getId() { return id; }
        public void setId(String id) { this.id = id; }
    }
    ```
    Note: If BaseRXObject cannot be extended in test (abstract issues), use a mock instead.

    **findById Tests (~4 tests):**

    1. `findById_returnsConvertedMap()`:
       - Mock metadataService.getProjectionEntity to return Optional.of(entityMeta)
       - Mock entityClassResolver.resolveByTableId to return TestEntity.class
       - Mock entityManager.find to return a TestEntity
       - Mock converter.convertToMap to return expected Map
       - Call findById("id1", "projection", "entity")
       - Assert result equals expected Map
       - Verify converter.convertToMap was called with the entity and metadata

    2. `findById_throwsWhenEntityNotFound()`:
       - Mock entityManager.find to return null
       - assertThrows(EntityNotFoundException.class, () -> repo.findById("id1", "proj", "ent"))

    3. `findById_throwsWhenMetadataNotFound()`:
       - Mock metadataService.getProjectionEntity to return Optional.empty()
       - assertThrows(DynamicRepositoryException.class, () -> repo.findById("id1", "proj", "ent"))

    4. `findById_resolvesEntityClassFromTableId()`:
       - Verify entityClassResolver.resolveByTableId is called with the correct tableId from metadata

    **findAll Tests (~3 tests):**

    5. `findAll_returnsPaginatedResults()`:
       - Mock CriteriaBuilder, CriteriaQuery, Root, TypedQuery
       - This is complex mocking. Setup:
         - entityManager.getCriteriaBuilder() -> mock CriteriaBuilder
         - cb.createQuery(Long.class) -> mock CriteriaQuery<Long>
         - cb.createQuery(entityClass) -> mock CriteriaQuery<Object>
         - count query returns 2L
         - data query returns list of 2 entities
         - converter.convertToMap returns a Map for each
       - Call findAll with Pageable.ofSize(10)
       - Assert result.getTotalElements() == 2
       - Assert result.getContent().size() == 2

    6. `findAll_appliesSorting()`:
       - Pass Pageable with Sort.by("name")
       - Verify cb.asc() or cb.desc() is called (via ArgumentCaptor or verify)

    7. `findAll_withEmptyFilters()`:
       - Call with empty filters map
       - Verify no predicates added to where clause

    **save/update Tests (~8 tests):**

    8. `save_followsExactOrderOfOperations()`:
       - This is the MOST CRITICAL test. Use InOrder verification:
       ```java
       InOrder inOrder = inOrder(transactionHandler, converter, auditService,
                                  validator, entityManager, externalIdService, postSyncService);
       ```
       - Call save(dto, "proj", "entity")
       - Verify order:
         1. transactionHandler.begin()
         2. converter.convertToEntity(dto, null/existing, meta, fields)
         3. auditService.setAuditValues(entity) (if BaseRXObject)
         4. validator.validate(entity)
         5. entityManager.merge(entity) -- first save
         6. entityManager.flush()
         7. externalIdService.add(tableId, dtoId, entity)
         8. externalIdService.flush() -- first flush
         9. entityManager.merge(entity) -- second save
         10. postSyncService.flush()
         11. externalIdService.flush() -- second flush
         12. transactionHandler.commit()
       - Mock entityManager.merge to return the entity
       - Mock entityManager.find for the final fresh read

    9. `save_upsertChecksExistenceById()`:
       - DTO has "id" = "existing-id"
       - Mock entityManager.find to return an existing entity
       - Verify converter.convertToEntity receives the existing entity (not null)

    10. `save_createsNewWhenIdNotFound()`:
        - DTO has "id" = "new-id"
        - Mock entityManager.find to return null
        - Verify converter.convertToEntity receives null as existingEntity

    11. `save_setsAuditForBaseRXObject()`:
        - Mock converter to return a BaseRXObject (or mock)
        - Verify auditService.setAuditValues was called

    12. `save_skipsAuditForNonBaseRXObject()`:
        - Mock converter to return a PlainEntity (not BaseRXObject)
        - Verify auditService.setAuditValues was NEVER called

    13. `save_callsExternalIdFlushTwice()`:
        - Call save
        - verify(externalIdService, times(2)).flush()

    14. `save_validationSkipsIdProperty()`:
        - Mock validator.validate to return a Set with one violation where propertyPath.toString() == "id"
        - Call save
        - Should NOT throw (id violation is skipped)

    15. `save_validationThrowsForNonIdViolation()`:
        - Mock validator.validate to return a Set with one violation where propertyPath.toString() == "name"
        - assertThrows(ResponseStatusException.class, () -> repo.save(dto, "proj", "ent"))

    **saveBatch Tests (~3 tests):**

    16. `saveBatch_processesAllInSingleTransaction()`:
        - Pass list of 3 DTOs
        - Verify transactionHandler.begin() called exactly once
        - Verify transactionHandler.commit() called exactly once
        - Verify entityManager.merge called 6 times (2 per entity: first save + second save)

    17. `saveBatch_returnsResultForEachDto()`:
        - Pass list of 2 DTOs
        - Assert result.size() == 2

    18. `saveBatch_propagatesExceptionWithoutCommit()`:
        - Mock converter.convertToEntity to throw on second DTO
        - assertThrows on saveBatch
        - Verify transactionHandler.commit() was NEVER called

    **Mocking tips:**
    - For CriteriaBuilder mocking in findAll, you need deep mocking. Consider using `mock(CriteriaBuilder.class, RETURNS_DEEP_STUBS)` or carefully chain when().thenReturn() for each CriteriaBuilder method call.
    - For Validator, mock ConstraintViolation with propertyPath:
      ```java
      ConstraintViolation<Object> violation = mock(ConstraintViolation.class);
      Path path = mock(Path.class);
      when(path.toString()).thenReturn("id");
      when(violation.getPropertyPath()).thenReturn(path);
      when(validator.validate(any())).thenReturn(Set.of(violation));
      ```
    - For entityManager.merge(), return the same entity: `when(entityManager.merge(any())).thenAnswer(inv -> inv.getArgument(0))`
  </action>
  <verify>
    - File exists at expected path
    - Contains @ExtendWith(MockitoExtension.class)
    - Contains at least 16 @Test methods
    - InOrder verification present for save order test
    - verify(externalIdService, times(2)).flush() present
    - Test for validation id skip present
  </verify>
  <done>
    DynamicRepository has 18+ unit tests covering: findById (success, not-found, metadata-not-found), findAll (pagination, sorting, empty filters), save (exact order verification, upsert, audit for BaseRXObject, audit skip, double externalId flush, validation id skip, validation failure), and saveBatch (single transaction, result count, exception handling).
  </done>
</task>

</tasks>

<verification>
After both tasks complete, verify:
1. Two test files exist in `com.etendorx.das.unit.repository` package
2. EntityClassResolverTest has 8+ tests covering all resolution paths
3. DynamicRepositoryTest has 18+ tests covering all CRUD operations
4. Critical test present: InOrder verification of save order of operations
5. Critical test present: externalIdService.flush() called twice
6. Critical test present: validation skips "id" property
7. Test style matches Phase 2 conventions: @ExtendWith(MockitoExtension.class), AAA pattern, manual construction
</verification>

<success_criteria>
- EntityClassResolver tests verify metamodel scanning, resolution by table ID and name, error handling
- DynamicRepository tests verify exact save order matching BaseDTORepositoryDefault
- Validation tests confirm "id" skip and non-id rejection
- Batch tests confirm single-transaction semantics
- All tests use Mockito with manual constructor injection (consistent with Phase 2 test patterns)
- Test coverage: findById (4), findAll (3), save/update (8), saveBatch (3), EntityClassResolver (8) = ~26 tests
</success_criteria>

<output>
After completion, create `.planning/phases/03-generic-repository-layer/03-02-SUMMARY.md`
</output>
