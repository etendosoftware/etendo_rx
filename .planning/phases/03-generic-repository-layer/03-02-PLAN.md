---
phase: 03-generic-repository-layer
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - modules_core/com.etendorx.das/src/test/java/com/etendorx/das/unit/repository/EntityClassResolverTest.java
  - modules_core/com.etendorx.das/src/test/java/com/etendorx/das/unit/repository/DynamicRepositoryTest.java
autonomous: true

must_haves:
  truths:
    - "EntityClassResolver correctly maps TABLE_ID to entity classes"
    - "EntityClassResolver correctly maps table names to entity classes"
    - "EntityClassResolver throws when table ID is not found"
    - "DynamicRepository.findById returns converted Map for existing entity"
    - "DynamicRepository.findById throws EntityNotFoundException for missing entity"
    - "DynamicRepository.findAll returns paginated results with correct total"
    - "DynamicRepository.save follows exact order: pre-instantiate -> convert (includes audit) -> validate -> merge -> externalId.add -> flush -> merge -> postSync.flush -> externalId.flush"
    - "DynamicRepository.save does NOT call auditService.setAuditValues() directly (converter handles it)"
    - "DynamicRepository.save pre-instantiates new entities via EntityClassResolver, never passing null to converter"
    - "DynamicRepository.saveBatch wraps all entities in single begin/commit"
    - "DynamicRepository validation skips id property violations"
  artifacts:
    - path: "modules_core/com.etendorx.das/src/test/java/com/etendorx/das/unit/repository/EntityClassResolverTest.java"
      provides: "Unit tests for metamodel-based entity class resolution"
      min_lines: 80
    - path: "modules_core/com.etendorx.das/src/test/java/com/etendorx/das/unit/repository/DynamicRepositoryTest.java"
      provides: "Unit tests for CRUD, batch, pagination, and validation"
      min_lines: 200
  key_links:
    - from: "EntityClassResolverTest.java"
      to: "EntityClassResolver"
      via: "direct instantiation with mocked EntityManager"
      pattern: "EntityClassResolver"
    - from: "DynamicRepositoryTest.java"
      to: "DynamicRepository"
      via: "manual constructor with all mocked dependencies"
      pattern: "DynamicRepository"
    - from: "DynamicRepositoryTest.java"
      to: "verify.*transactionHandler"
      via: "Mockito verify for transaction order"
      pattern: "verify.*begin|verify.*commit"
---

<objective>
Create comprehensive unit tests for the Generic Repository Layer: EntityClassResolver metamodel resolution tests and DynamicRepository CRUD/batch/pagination/validation tests.

Purpose: Verify correct behavior of all repository operations, especially the critical transaction orchestration flow that must match BaseDTORepositoryDefault exactly (with the two documented adaptations: pre-instantiation via metamodel and audit handled by converter). Tests provide regression safety net for the dynamic repository.

Output: Two test files covering EntityClassResolver and DynamicRepository with ~25-35 tests total.
</objective>

<execution_context>
@/Users/sebastianbarrozo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sebastianbarrozo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-generic-repository-layer/03-RESEARCH.md
@.planning/phases/03-generic-repository-layer/03-01-SUMMARY.md

Key source files to test:
@modules_core/com.etendorx.das/src/main/java/com/etendorx/das/repository/EntityClassResolver.java
@modules_core/com.etendorx.das/src/main/java/com/etendorx/das/repository/DynamicRepository.java
@modules_core/com.etendorx.das/src/main/java/com/etendorx/das/repository/DynamicRepositoryException.java

Reference for test patterns (Phase 2 tests):
@modules_core/com.etendorx.das/src/test/java/com/etendorx/das/unit/converter/DynamicDTOConverterTest.java

CRITICAL: Read DynamicDTOConverter.java to understand that audit is handled INSIDE the converter:
@modules_core/com.etendorx.das/src/main/java/com/etendorx/das/converter/DynamicDTOConverter.java
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create EntityClassResolver unit tests</name>
  <files>
    modules_core/com.etendorx.das/src/test/java/com/etendorx/das/unit/repository/EntityClassResolverTest.java
  </files>
  <action>
    Create EntityClassResolverTest.java in `com.etendorx.das.unit.repository` package (~100 lines).

    **Test setup:**
    - @ExtendWith(MockitoExtension.class)
    - @Mock EntityManager entityManager
    - @Mock Metamodel metamodel
    - Manual construction of EntityClassResolver in @BeforeEach (inject mocked EntityManager)

    **Helper setup for mocking metamodel:**
    Create a helper method that prepares mock EntityType objects. For each test entity:
    - Mock EntityType with getJavaType() returning a test class
    - The test class should have @jakarta.persistence.Table(name = "test_table") annotation
    - The test class should have a static TABLE_ID field
    - Use inner test classes annotated with @Table for this purpose:
      ```java
      @jakarta.persistence.Table(name = "test_table")
      static class TestEntity {
          public static final String TABLE_ID = "100";
      }

      @jakarta.persistence.Table(name = "another_table")
      static class AnotherEntity {
          public static final String TABLE_ID = "200";
      }

      // Entity without TABLE_ID
      @jakarta.persistence.Table(name = "no_tableid")
      static class NoTableIdEntity {
      }
      ```

    **Tests (~8 tests):**

    1. `init_scansMetamodelAndPopulatesMaps()`:
       - Mock metamodel to return Set of EntityTypes for TestEntity and AnotherEntity
       - Call init()
       - Assert resolveByTableId("100") returns TestEntity.class
       - Assert resolveByTableId("200") returns AnotherEntity.class

    2. `resolveByTableId_returnsCorrectClass()`:
       - Setup metamodel with TestEntity
       - Call init(), then resolveByTableId("100")
       - Assert returns TestEntity.class

    3. `resolveByTableId_throwsWhenNotFound()`:
       - Setup empty or non-matching metamodel
       - Call init()
       - assertThrows(DynamicRepositoryException.class, () -> resolver.resolveByTableId("999"))

    4. `resolveByTableName_returnsCorrectClass()`:
       - Setup metamodel with TestEntity (table name "test_table")
       - Call init(), then resolveByTableName("test_table")
       - Assert returns TestEntity.class

    5. `resolveByTableName_isCaseInsensitive()`:
       - Verify resolveByTableName("TEST_TABLE") also works (annotation value stored lowercase)

    6. `resolveByTableName_throwsWhenNotFound()`:
       - assertThrows(DynamicRepositoryException.class, () -> resolver.resolveByTableName("nonexistent"))

    7. `init_handlesEntityWithoutTableId()`:
       - Include NoTableIdEntity in metamodel (has @Table but no TABLE_ID field)
       - Call init() -- should not throw
       - Assert resolveByTableName("no_tableid") returns NoTableIdEntity.class
       - Assert resolveByTableId with any ID does not return NoTableIdEntity

    8. `init_handlesEntityWithoutTableAnnotation()`:
       - Create an inner entity class WITHOUT @Table annotation
       - Include in metamodel
       - Call init() -- should not throw (gracefully skips)

    **Mocking pattern for EntityManager.getMetamodel():**
    ```java
    when(entityManager.getMetamodel()).thenReturn(metamodel);
    EntityType<?> mockType = mock(EntityType.class);
    when(mockType.getJavaType()).thenReturn((Class) TestEntity.class);
    when(metamodel.getEntities()).thenReturn(Set.of(mockType));
    ```
  </action>
  <verify>
    - File exists at expected path
    - Contains @ExtendWith(MockitoExtension.class)
    - Contains at least 7 @Test methods
    - All test methods follow AAA pattern (Arrange-Act-Assert)
    - Inner test entity classes have @Table annotations
  </verify>
  <done>
    EntityClassResolver has 8 unit tests covering: metamodel scanning, table ID resolution, table name resolution, case insensitivity, not-found exceptions, entities without TABLE_ID, and entities without @Table annotation.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create DynamicRepository unit tests</name>
  <files>
    modules_core/com.etendorx.das/src/test/java/com/etendorx/das/unit/repository/DynamicRepositoryTest.java
  </files>
  <action>
    Create DynamicRepositoryTest.java in `com.etendorx.das.unit.repository` package (~300 lines).

    **Test setup:**
    - @ExtendWith(MockitoExtension.class)
    - @Mock for ALL dependencies: EntityManager, DynamicDTOConverter, DynamicMetadataService, AuditServiceInterceptor, RestCallTransactionHandler, ExternalIdService, PostSyncService, Validator, EntityClassResolver
    - Manual construction of DynamicRepository in @BeforeEach with all mocked dependencies
    - NOTE: DynamicRepository may have Optional<DefaultValuesHandler> -- if so, pass Optional.empty()
    - Helper methods createEntityMetadata() and createFieldMetadata() (same pattern as Phase 2 tests)

    **Inner test classes:**
    ```java
    // Simple POJO for testing entity operations
    static class TestEntity extends BaseRXObject {
        private String id;
        public String getId() { return id; }
        public void setId(String id) { this.id = id; }
        // Minimal BaseRXObject stubs as needed
    }

    // Non-BaseRXObject entity for testing audit skip
    static class PlainEntity {
        private String id;
        public String getId() { return id; }
        public void setId(String id) { this.id = id; }
    }
    ```
    Note: If BaseRXObject cannot be extended in test (abstract issues), use a mock instead.

    **findById Tests (~4 tests):**

    1. `findById_returnsConvertedMap()`:
       - Mock metadataService.getProjectionEntity to return Optional.of(entityMeta)
       - Mock entityClassResolver.resolveByTableId to return TestEntity.class
       - Mock entityManager.find to return a TestEntity
       - Mock converter.convertToMap to return expected Map
       - Call findById("id1", "projection", "entity")
       - Assert result equals expected Map
       - Verify converter.convertToMap was called with the entity and metadata

    2. `findById_throwsWhenEntityNotFound()`:
       - Mock entityManager.find to return null
       - assertThrows(EntityNotFoundException.class, () -> repo.findById("id1", "proj", "ent"))

    3. `findById_throwsWhenMetadataNotFound()`:
       - Mock metadataService.getProjectionEntity to return Optional.empty()
       - assertThrows(DynamicRepositoryException.class, () -> repo.findById("id1", "proj", "ent"))

    4. `findById_resolvesEntityClassFromTableId()`:
       - Verify entityClassResolver.resolveByTableId is called with the correct tableId from metadata

    **findAll Tests (~3 tests):**

    5. `findAll_returnsPaginatedResults()`:
       - Mock CriteriaBuilder, CriteriaQuery, Root, TypedQuery
       - This is complex mocking. Setup:
         - entityManager.getCriteriaBuilder() -> mock CriteriaBuilder
         - cb.createQuery(Long.class) -> mock CriteriaQuery<Long>
         - cb.createQuery(entityClass) -> mock CriteriaQuery<Object>
         - count query returns 2L
         - data query returns list of 2 entities
         - converter.convertToMap returns a Map for each
       - Call findAll with Pageable.ofSize(10)
       - Assert result.getTotalElements() == 2
       - Assert result.getContent().size() == 2

    6. `findAll_appliesSorting()`:
       - Pass Pageable with Sort.by("name")
       - Verify cb.asc() or cb.desc() is called (via ArgumentCaptor or verify)

    7. `findAll_withEmptyFilters()`:
       - Call with empty filters map
       - Verify no predicates added to where clause

    **save/update Tests (~9 tests):**

    8. `save_followsExactOrderOfOperations()`:
       - This is the MOST CRITICAL test. Use InOrder verification:
       ```java
       InOrder inOrder = inOrder(transactionHandler, converter,
                                  validator, entityManager, externalIdService, postSyncService);
       ```
       - NOTE: auditService is NOT in the InOrder list because DynamicRepository does not call it directly (converter handles audit internally)
       - Call save(dto, "proj", "entity")
       - Verify order:
         1. transactionHandler.begin()
         2. converter.convertToEntity(dto, preInstantiatedEntity, meta, fields) -- entity is ALWAYS non-null
         3. validator.validate(entity)
         4. entityManager.merge(entity) -- first save
         5. entityManager.flush()
         6. externalIdService.add(tableId, dtoId, entity)
         7. externalIdService.flush() -- first flush
         8. entityManager.merge(entity) -- second save
         9. postSyncService.flush()
         10. externalIdService.flush() -- second flush
         11. transactionHandler.commit()
       - Mock entityManager.merge to return the entity
       - Mock entityManager.find for the final fresh read

    9. `save_preInstantiatesNewEntityViaMetamodel()`:
       - DTO has no "id" (new entity)
       - Verify converter.convertToEntity receives a NON-NULL entity (pre-instantiated via entityClass.newInstance())
       - Verify auditService.setAuditValues is NEVER called directly by the repository
       - Use ArgumentCaptor on converter.convertToEntity to capture the entity argument and assert it is not null

    10. `save_upsertChecksExistenceById()`:
        - DTO has "id" = "existing-id"
        - Mock entityManager.find to return an existing entity
        - Verify converter.convertToEntity receives the existing entity (not a new instance)

    11. `save_createsNewInstanceWhenIdNotFoundInDb()`:
        - DTO has "id" = "new-id"
        - Mock entityManager.find to return null
        - Verify converter.convertToEntity receives a non-null entity (pre-instantiated, NOT null)

    12. `save_doesNotCallAuditServiceDirectly()`:
        - Call save
        - verify(auditService, never()).setAuditValues(any())
        - This confirms the repository delegates audit to the converter

    13. `save_callsExternalIdFlushTwice()`:
        - Call save
        - verify(externalIdService, times(2)).flush()

    14. `save_validationSkipsIdProperty()`:
        - Mock validator.validate to return a Set with one violation where propertyPath.toString() == "id"
        - Call save
        - Should NOT throw (id violation is skipped)

    15. `save_validationThrowsForNonIdViolation()`:
        - Mock validator.validate to return a Set with one violation where propertyPath.toString() == "name"
        - assertThrows(ResponseStatusException.class, () -> repo.save(dto, "proj", "ent"))

    16. `save_neverUsesAdTableForInstantiation()`:
        - Verify no JPQL query containing "ADTable" or "javaClassName" is executed
        - verify(entityManager, never()).createQuery(contains("ADTable"))
        - This is a negative test confirming the locked decision

    **saveBatch Tests (~3 tests):**

    17. `saveBatch_processesAllInSingleTransaction()`:
        - Pass list of 3 DTOs
        - Verify transactionHandler.begin() called exactly once
        - Verify transactionHandler.commit() called exactly once
        - Verify entityManager.merge called 6 times (2 per entity: first save + second save)

    18. `saveBatch_returnsResultForEachDto()`:
        - Pass list of 2 DTOs
        - Assert result.size() == 2

    19. `saveBatch_propagatesExceptionWithoutCommit()`:
        - Mock converter.convertToEntity to throw on second DTO
        - assertThrows on saveBatch
        - Verify transactionHandler.commit() was NEVER called

    **Mocking tips:**
    - For CriteriaBuilder mocking in findAll, you need deep mocking. Consider using `mock(CriteriaBuilder.class, RETURNS_DEEP_STUBS)` or carefully chain when().thenReturn() for each CriteriaBuilder method call.
    - For Validator, mock ConstraintViolation with propertyPath:
      ```java
      ConstraintViolation<Object> violation = mock(ConstraintViolation.class);
      Path path = mock(Path.class);
      when(path.toString()).thenReturn("id");
      when(violation.getPropertyPath()).thenReturn(path);
      when(validator.validate(any())).thenReturn(Set.of(violation));
      ```
    - For entityManager.merge(), return the same entity: `when(entityManager.merge(any())).thenAnswer(inv -> inv.getArgument(0))`
    - For pre-instantiation tests, use ArgumentCaptor<Object> on converter.convertToEntity's second parameter to verify it's non-null
  </action>
  <verify>
    - File exists at expected path
    - Contains @ExtendWith(MockitoExtension.class)
    - Contains at least 17 @Test methods
    - InOrder verification present for save order test (WITHOUT auditService in the chain)
    - verify(externalIdService, times(2)).flush() present
    - verify(auditService, never()).setAuditValues(any()) present -- confirms no duplicate audit
    - Test for validation id skip present
    - Test for pre-instantiation via ArgumentCaptor present
    - Test confirming no AD_Table usage present
  </verify>
  <done>
    DynamicRepository has 19+ unit tests covering: findById (success, not-found, metadata-not-found), findAll (pagination, sorting, empty filters), save (exact order verification WITHOUT audit call, pre-instantiation of new entities, upsert, no duplicate audit, double externalId flush, validation id skip, validation failure, no AD_Table usage), and saveBatch (single transaction, result count, exception handling).
  </done>
</task>

</tasks>

<verification>
After both tasks complete, verify:
1. Two test files exist in `com.etendorx.das.unit.repository` package
2. EntityClassResolverTest has 8+ tests covering all resolution paths
3. DynamicRepositoryTest has 19+ tests covering all CRUD operations
4. Critical test present: InOrder verification of save order (WITHOUT auditService)
5. Critical test present: verify(auditService, never()).setAuditValues(any())
6. Critical test present: ArgumentCaptor verifies converter always receives non-null entity
7. Critical test present: externalIdService.flush() called twice
8. Critical test present: validation skips "id" property
9. Critical test present: no AD_Table/javaClassName queries executed
10. Test style matches Phase 2 conventions: @ExtendWith(MockitoExtension.class), AAA pattern, manual construction
</verification>

<success_criteria>
- EntityClassResolver tests verify metamodel scanning, resolution by table ID and name, error handling
- DynamicRepository tests verify exact save order matching BaseDTORepositoryDefault (with metamodel pre-instantiation and converter-handled audit)
- Save order test confirms auditService is NOT called by repository (converter handles it)
- Pre-instantiation test confirms converter always receives non-null entity
- Validation tests confirm "id" skip and non-id rejection
- Batch tests confirm single-transaction semantics
- Negative test confirms no AD_Table usage for entity instantiation
- All tests use Mockito with manual constructor injection (consistent with Phase 2 test patterns)
- Test coverage: findById (4), findAll (3), save/update (9), saveBatch (3), EntityClassResolver (8) = ~27 tests
</success_criteria>

<output>
After completion, create `.planning/phases/03-generic-repository-layer/03-02-SUMMARY.md`
</output>
