---
phase: 01-dynamic-metadata-service
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - modules_core/com.etendorx.das/build.gradle
  - modules_core/com.etendorx.das/src/main/java/com/etendorx/das/metadata/models/FieldMappingType.java
  - modules_core/com.etendorx.das/src/main/java/com/etendorx/das/metadata/models/ProjectionMetadata.java
  - modules_core/com.etendorx.das/src/main/java/com/etendorx/das/metadata/models/EntityMetadata.java
  - modules_core/com.etendorx.das/src/main/java/com/etendorx/das/metadata/models/FieldMetadata.java
  - modules_core/com.etendorx.das/src/main/java/com/etendorx/das/metadata/config/MetadataCacheConfig.java
  - modules_core/com.etendorx.das/src/main/java/com/etendorx/das/metadata/DynamicMetadataService.java
  - modules_core/com.etendorx.das/src/main/java/com/etendorx/das/metadata/DynamicMetadataServiceImpl.java
autonomous: true

must_haves:
  truths:
    - "Projection metadata can be loaded from etrx_projection, etrx_projection_entity, etrx_entity_field tables at runtime"
    - "All four field mapping types (DM, JM, CV, JP) are correctly represented in the metadata model"
    - "Cache serves repeated lookups without additional DB queries"
    - "Cache can be manually invalidated, forcing reload on next access"
    - "All projections are preloaded into cache at application startup"
  artifacts:
    - path: "modules_core/com.etendorx.das/build.gradle"
      provides: "Caffeine and spring-boot-starter-cache dependencies"
      contains: "caffeine"
    - path: "modules_core/com.etendorx.das/src/main/java/com/etendorx/das/metadata/models/FieldMappingType.java"
      provides: "Type-safe enum for field mapping types"
      contains: "DIRECT_MAPPING"
    - path: "modules_core/com.etendorx.das/src/main/java/com/etendorx/das/metadata/models/ProjectionMetadata.java"
      provides: "Immutable projection metadata record"
      contains: "record ProjectionMetadata"
    - path: "modules_core/com.etendorx.das/src/main/java/com/etendorx/das/metadata/models/EntityMetadata.java"
      provides: "Immutable entity metadata record"
      contains: "record EntityMetadata"
    - path: "modules_core/com.etendorx.das/src/main/java/com/etendorx/das/metadata/models/FieldMetadata.java"
      provides: "Immutable field metadata record"
      contains: "record FieldMetadata"
    - path: "modules_core/com.etendorx.das/src/main/java/com/etendorx/das/metadata/config/MetadataCacheConfig.java"
      provides: "Caffeine cache manager configuration"
      contains: "@EnableCaching"
    - path: "modules_core/com.etendorx.das/src/main/java/com/etendorx/das/metadata/DynamicMetadataService.java"
      provides: "Public API interface for metadata queries"
      exports: ["getProjection", "getProjectionEntity", "getFields", "invalidateCache"]
    - path: "modules_core/com.etendorx.das/src/main/java/com/etendorx/das/metadata/DynamicMetadataServiceImpl.java"
      provides: "Service implementation with caching and DB loading"
      contains: "@Cacheable"
  key_links:
    - from: "DynamicMetadataServiceImpl.java"
      to: "ETRX_ProjectionRepository"
      via: "constructor injection + EntityManager JPQL queries"
      pattern: "EntityManager|ETRX_ProjectionRepository"
    - from: "DynamicMetadataServiceImpl.java"
      to: "ProjectionMetadata/EntityMetadata/FieldMetadata records"
      via: "toProjectionMetadata/toEntityMetadata/toFieldMetadata conversion methods"
      pattern: "toProjectionMetadata|toEntityMetadata|toFieldMetadata"
    - from: "DynamicMetadataServiceImpl.java"
      to: "MetadataCacheConfig"
      via: "Spring Cache abstraction (@Cacheable referencing cache names defined in config)"
      pattern: "@Cacheable.*projections"
---

<objective>
Create the DynamicMetadataService: immutable metadata models, Caffeine cache configuration, and the service implementation that loads projection/entity/field metadata from the database and caches it in memory.

Purpose: This is the foundation for the entire Dynamic DAS system. All downstream components (converter, repository, controller) depend on this service to understand projection structure at runtime.

Output: Working DynamicMetadataService with API methods `getProjection(name)`, `getProjectionEntity(projectionName, entityName)`, `getFields(projectionEntityId)`, and `invalidateCache()`. Cache preloads at startup.
</objective>

<execution_context>
@/Users/sebastianbarrozo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sebastianbarrozo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-dynamic-metadata-service/01-RESEARCH.md

Key existing files to reference:
@modules_core/com.etendorx.das/build.gradle
@modules_core/com.etendorx.das/src/main/java/com/etendorx/das/EtendorxDasApplication.java
@modules_gen/com.etendorx.entities/src/main/entities/com/etendoerp/etendorx/data/ETRXProjection.java
@modules_gen/com.etendorx.entities/src/main/entities/com/etendoerp/etendorx/data/ETRXProjectionEntity.java
@modules_gen/com.etendorx.entities/src/main/entities/com/etendoerp/etendorx/data/ETRXEntityField.java
@modules_gen/com.etendorx.entities/src/main/entities/com/etendoerp/etendorx/data/ETRXJavaMapping.java
@modules_gen/com.etendorx.entities/src/main/entities/com/etendoerp/etendorx/data/ConstantValue.java
@modules_gen/com.etendorx.entities/src/main/jparepo/com/etendorx/entities/jparepo/ETRX_ProjectionRepository.java
@modules_gen/com.etendorx.entities/src/main/entities/com/etendorx/entities/entities/BaseDASRepository.java
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add dependencies and create metadata models</name>
  <files>
    modules_core/com.etendorx.das/build.gradle
    modules_core/com.etendorx.das/src/main/java/com/etendorx/das/metadata/models/FieldMappingType.java
    modules_core/com.etendorx.das/src/main/java/com/etendorx/das/metadata/models/ProjectionMetadata.java
    modules_core/com.etendorx.das/src/main/java/com/etendorx/das/metadata/models/EntityMetadata.java
    modules_core/com.etendorx.das/src/main/java/com/etendorx/das/metadata/models/FieldMetadata.java
  </files>
  <action>
    1. **Modify `build.gradle`** - Add two dependencies to the `dependencies` block:
       ```
       implementation 'org.springframework.boot:spring-boot-starter-cache'
       implementation 'com.github.ben-manes.caffeine:caffeine:3.1.8'
       ```
       Add them near the existing `spring-boot-starter-*` dependencies. Do NOT change anything else in build.gradle.

    2. **Create `FieldMappingType.java`** - Enum with four values:
       - `DIRECT_MAPPING("DM")` - Direct property-to-field mapping
       - `JAVA_MAPPING("JM")` - Custom Java converter via qualifier
       - `CONSTANT_VALUE("CV")` - Static constant value
       - `JSON_PATH("JP")` - JsonPath extraction
       Include a `code` field (the 2-char DB value), a constructor, a static `fromCode(String)` method that returns the enum for a DB code (throw IllegalArgumentException for unknown codes), and a `getCode()` getter. Package: `com.etendorx.das.metadata.models`.

    3. **Create `FieldMetadata.java`** - Java record in `com.etendorx.das.metadata.models`:
       ```java
       public record FieldMetadata(
           String id,
           String name,
           String property,
           FieldMappingType fieldMapping,
           boolean mandatory,
           boolean identifiesUnivocally,
           Long line,
           // JM-specific: qualifier of the Java mapping bean
           String javaMappingQualifier,
           // CV-specific: the constant value string
           String constantValue,
           // JP-specific: the jsonpath expression
           String jsonPath,
           // Related entity projection entity ID (for entity references)
           String relatedProjectionEntityId,
           boolean createRelated
       ) {}
       ```
       This record captures ALL field-level metadata needed by downstream converter. The nullable fields (javaMappingQualifier, constantValue, jsonPath, relatedProjectionEntityId) are populated based on fieldMapping type.

    4. **Create `EntityMetadata.java`** - Java record in `com.etendorx.das.metadata.models`:
       ```java
       public record EntityMetadata(
           String id,
           String name,
           String tableId,
           String mappingType,
           boolean identity,
           boolean restEndPoint,
           String externalName,
           List<FieldMetadata> fields
       ) {}
       ```
       Use `java.util.List`. Include `mappingType`, `restEndPoint`, and `externalName` from ETRXProjectionEntity - these are needed by Phase 4 (controller endpoint registration).

    5. **Create `ProjectionMetadata.java`** - Java record in `com.etendorx.das.metadata.models`:
       ```java
       public record ProjectionMetadata(
           String id,
           String name,
           String description,
           boolean grpc,
           List<EntityMetadata> entities
       ) {
           /**
            * Find an entity within this projection by name.
            * @return Optional containing the entity metadata, or empty if not found
            */
           public Optional<EntityMetadata> findEntity(String entityName) {
               return entities.stream()
                   .filter(e -> e.name().equals(entityName))
                   .findFirst();
           }
       }
       ```
       Include `description` from ETRXProjection. Add `findEntity(String entityName)` convenience method that filters the entities list - this supports the `getProjectionEntity(projectionName, entityName)` API without extra DB calls.
  </action>
  <verify>
    All 5 files exist at the specified paths. Run: `find modules_core/com.etendorx.das/src/main/java/com/etendorx/das/metadata -name "*.java" | sort` and confirm all 5 files are listed. Verify `build.gradle` contains `caffeine` dependency.
  </verify>
  <done>
    - build.gradle has spring-boot-starter-cache and caffeine dependencies
    - FieldMappingType enum has 4 values with fromCode() parsing
    - FieldMetadata record captures all field properties including mapping-type-specific nullable fields
    - EntityMetadata record captures all entity properties including restEndPoint and externalName
    - ProjectionMetadata record has findEntity() convenience method
    - All records use immutable fields (Java record pattern)
  </done>
</task>

<task type="auto">
  <name>Task 2: Create cache config and DynamicMetadataService implementation</name>
  <files>
    modules_core/com.etendorx.das/src/main/java/com/etendorx/das/metadata/config/MetadataCacheConfig.java
    modules_core/com.etendorx.das/src/main/java/com/etendorx/das/metadata/DynamicMetadataService.java
    modules_core/com.etendorx.das/src/main/java/com/etendorx/das/metadata/DynamicMetadataServiceImpl.java
  </files>
  <action>
    1. **Create `MetadataCacheConfig.java`** in `com.etendorx.das.metadata.config`:
       ```java
       @Configuration
       @EnableCaching
       public class MetadataCacheConfig {
           @Bean
           public CacheManager cacheManager() {
               CaffeineCacheManager cacheManager = new CaffeineCacheManager(
                   "projections", "projectionsByName"
               );
               cacheManager.setCaffeine(Caffeine.newBuilder()
                   .maximumSize(500)
                   .expireAfterWrite(Duration.ofHours(24))
                   .recordStats());
               return cacheManager;
           }
       }
       ```
       Two cache regions: `projections` for all-projections map, `projectionsByName` for individual lookups. Use 24h expiry as safety net (primary invalidation is manual). Import from `com.github.ben-manes.caffeine.cache.Caffeine`, `org.springframework.cache.CacheManager`, `org.springframework.cache.caffeine.CaffeineCacheManager`.

    2. **Create `DynamicMetadataService.java`** interface in `com.etendorx.das.metadata`:
       ```java
       public interface DynamicMetadataService {
           /**
            * Get projection metadata by name.
            * @param name the projection name (e.g., "Product", "BusinessPartner")
            * @return the projection metadata, or empty if not found
            */
           Optional<ProjectionMetadata> getProjection(String name);

           /**
            * Get a specific entity within a projection.
            * @param projectionName the projection name
            * @param entityName the entity name within the projection
            * @return the entity metadata, or empty if projection or entity not found
            */
           Optional<EntityMetadata> getProjectionEntity(String projectionName, String entityName);

           /**
            * Get all fields for a projection entity by its ID.
            * @param projectionEntityId the projection entity UUID
            * @return list of field metadata, empty list if entity not found
            */
           List<FieldMetadata> getFields(String projectionEntityId);

           /**
            * Get all loaded projection names.
            * @return set of projection names currently in cache
            */
           Set<String> getAllProjectionNames();

           /**
            * Invalidate all cached metadata, forcing reload on next access.
            */
           void invalidateCache();
       }
       ```

    3. **Create `DynamicMetadataServiceImpl.java`** in `com.etendorx.das.metadata`:

       **Critical design decisions:**
       - Inject `EntityManager` (NOT modify generated repos) for JPQL JOIN FETCH queries to avoid N+1 problem
       - Also inject `ETRX_ProjectionRepository` as fallback for simple lookups if needed
       - Convert JPA entities to immutable records BEFORE caching (avoids LazyInitializationException)
       - Use `@Cacheable("projectionsByName")` on `getProjection()` method
       - Self-invocation workaround: `preloadCache()` must NOT call `this.getProjection()` (bypasses proxy). Instead, load all projections directly in preloadCache, convert to records, and populate cache programmatically via CacheManager injection.

       Implementation:
       ```java
       @Service
       @Slf4j
       public class DynamicMetadataServiceImpl implements DynamicMetadataService {

           private final EntityManager entityManager;
           private final CacheManager cacheManager;

           public DynamicMetadataServiceImpl(EntityManager entityManager, CacheManager cacheManager) {
               this.entityManager = entityManager;
               this.cacheManager = cacheManager;
           }

           @EventListener(ApplicationReadyEvent.class)
           public void preloadCache() {
               log.info("Preloading projection metadata cache...");
               // Use JPQL with JOIN FETCH to load entire hierarchy in minimal queries
               // NOTE: Hibernate may not allow multiple collection fetches in one query.
               // Strategy: fetch projections with entities first, then fields per entity.
               List<ETRXProjection> projections = entityManager.createQuery(
                   "SELECT DISTINCT p FROM ETRX_Projection p " +
                   "LEFT JOIN FETCH p.eTRXProjectionEntityList",
                   ETRXProjection.class
               ).getResultList();

               Cache cache = cacheManager.getCache("projectionsByName");
               int count = 0;
               for (ETRXProjection projection : projections) {
                   // For each entity, eagerly load its fields within this transaction
                   for (ETRXProjectionEntity entity : projection.getETRXProjectionEntityList()) {
                       Hibernate.initialize(entity.getETRXEntityFieldList());
                       // Also initialize lazy relationships on each field
                       for (ETRXEntityField field : entity.getETRXEntityFieldList()) {
                           if (field.getJavaMapping() != null) {
                               Hibernate.initialize(field.getJavaMapping());
                           }
                           if (field.getEtrxConstantValue() != null) {
                               Hibernate.initialize(field.getEtrxConstantValue());
                           }
                           if (field.getEtrxProjectionEntityRelated() != null) {
                               Hibernate.initialize(field.getEtrxProjectionEntityRelated());
                           }
                       }
                   }
                   ProjectionMetadata metadata = toProjectionMetadata(projection);
                   if (cache != null) {
                       cache.put(metadata.name(), metadata);
                   }
                   count++;
               }
               log.info("Loaded {} projections into metadata cache", count);
           }

           @Override
           @Cacheable(value = "projectionsByName", key = "#name")
           public Optional<ProjectionMetadata> getProjection(String name) {
               log.debug("Cache miss for projection: {}", name);
               // This executes only on cache miss
               List<ETRXProjection> results = entityManager.createQuery(
                   "SELECT DISTINCT p FROM ETRX_Projection p " +
                   "LEFT JOIN FETCH p.eTRXProjectionEntityList e " +
                   "LEFT JOIN FETCH e.eTRXEntityFieldList " +
                   "WHERE p.name = :name",
                   ETRXProjection.class
               ).setParameter("name", name).getResultList();

               if (results.isEmpty()) {
                   return Optional.empty();
               }

               ETRXProjection projection = results.get(0);
               // Initialize lazy relationships on fields
               for (ETRXProjectionEntity entity : projection.getETRXProjectionEntityList()) {
                   for (ETRXEntityField field : entity.getETRXEntityFieldList()) {
                       if (field.getJavaMapping() != null) {
                           Hibernate.initialize(field.getJavaMapping());
                       }
                       if (field.getEtrxConstantValue() != null) {
                           Hibernate.initialize(field.getEtrxConstantValue());
                       }
                       if (field.getEtrxProjectionEntityRelated() != null) {
                           Hibernate.initialize(field.getEtrxProjectionEntityRelated());
                       }
                   }
               }
               return Optional.of(toProjectionMetadata(projection));
           }

           @Override
           public Optional<EntityMetadata> getProjectionEntity(String projectionName, String entityName) {
               return getProjection(projectionName)
                   .flatMap(p -> p.findEntity(entityName));
           }

           @Override
           public List<FieldMetadata> getFields(String projectionEntityId) {
               // Search through all cached projections for the entity ID
               Cache cache = cacheManager.getCache("projectionsByName");
               if (cache != null) {
                   // Get the underlying Caffeine cache to iterate
                   Object nativeCache = cache.getNativeCache();
                   if (nativeCache instanceof com.github.ben-manes.caffeine.cache.Cache<?, ?> caffeineCache) {
                       for (Object value : caffeineCache.asMap().values()) {
                           // Spring Cache wraps values; unwrap if needed
                           ProjectionMetadata projection = unwrapCacheValue(value);
                           if (projection != null) {
                               for (EntityMetadata entity : projection.entities()) {
                                   if (entity.id().equals(projectionEntityId)) {
                                       return entity.fields();
                                   }
                               }
                           }
                       }
                   }
               }
               // Fallback: query DB directly if not in cache
               return loadFieldsFromDb(projectionEntityId);
           }

           @Override
           public Set<String> getAllProjectionNames() {
               Cache cache = cacheManager.getCache("projectionsByName");
               if (cache != null) {
                   Object nativeCache = cache.getNativeCache();
                   if (nativeCache instanceof com.github.ben-manes.caffeine.cache.Cache<?, ?> caffeineCache) {
                       return caffeineCache.asMap().keySet().stream()
                           .map(Object::toString)
                           .collect(Collectors.toSet());
                   }
               }
               return Set.of();
           }

           @Override
           @CacheEvict(value = "projectionsByName", allEntries = true)
           public void invalidateCache() {
               log.info("Projection metadata cache invalidated");
           }
       }
       ```

       **Additional private methods to implement:**

       - `toProjectionMetadata(ETRXProjection)` - Converts JPA entity to ProjectionMetadata record. Maps `getGRPC()` -> `grpc`, `getDescription()` -> `description`, converts entity list via `toEntityMetadata`.
       - `toEntityMetadata(ETRXProjectionEntity)` - Converts to EntityMetadata record. Maps `getTableEntity().getId()` -> `tableId`, `getIdentity()` -> `identity`, `getRestEndPoint()` -> `restEndPoint`, `getMappingType()` -> `mappingType`, `getExternalName()` -> `externalName`. Converts field list via `toFieldMetadata`.
       - `toFieldMetadata(ETRXEntityField)` - Converts to FieldMetadata record. Uses `FieldMappingType.fromCode(field.getFieldMapping())` for type safety. Extracts mapping-type-specific values:
         - For all: `name`, `property`, `ismandatory`, `identifiesUnivocally`, `line`
         - JM: `field.getJavaMapping().getQualifier()` (null-safe)
         - CV: `field.getEtrxConstantValue().getDefaultValue()` (null-safe)
         - JP: `field.getJsonpath()`
         - Related: `field.getEtrxProjectionEntityRelated().getId()` (null-safe)
         - `field.getCreateRelated()` -> `createRelated`
       - `unwrapCacheValue(Object)` - Handles Spring Cache wrapper: if value is `Optional`, unwrap; if `ProjectionMetadata`, return directly; otherwise null.
       - `loadFieldsFromDb(String projectionEntityId)` - Fallback JPQL query to load fields for a specific entity ID.

       **Imports needed:** `jakarta.persistence.EntityManager`, `org.hibernate.Hibernate`, `org.springframework.cache.Cache`, `org.springframework.cache.CacheManager`, `org.springframework.cache.annotation.Cacheable`, `org.springframework.cache.annotation.CacheEvict`, `org.springframework.boot.context.event.ApplicationReadyEvent`, `org.springframework.context.event.EventListener`, `org.springframework.stereotype.Service`, `lombok.extern.slf4j.Slf4j`, `java.util.*`, `java.util.stream.Collectors`.

       **Why `@EventListener(ApplicationReadyEvent.class)` instead of `@PostConstruct`:** The research identified that cache proxy may not be fully initialized during @PostConstruct. ApplicationReadyEvent fires after all beans and proxies are ready. Also, we populate cache programmatically via CacheManager (not via self-invocation of @Cacheable methods), which avoids the self-invocation proxy bypass problem entirely.

       **Why `EntityManager` instead of modifying generated repos:** The repositories in `modules_gen/` are generated code and should not be modified. Creating new Spring Data repository interfaces in the DAS module would require extending `@EnableJpaRepositories` scan paths. Using `EntityManager` directly with JPQL is cleaner and avoids coupling to generated code structure.
  </action>
  <verify>
    1. All 3 files exist at specified paths
    2. `DynamicMetadataService.java` declares all 5 API methods
    3. `DynamicMetadataServiceImpl.java` has `@Service`, `@Slf4j`, `@Cacheable`, `@CacheEvict`, `@EventListener` annotations
    4. `MetadataCacheConfig.java` has `@Configuration`, `@EnableCaching`, and defines CacheManager bean
    5. Run `./gradlew :com.etendorx.das:compileJava` to verify compilation (may fail due to test dependencies but main source should compile)
  </verify>
  <done>
    - MetadataCacheConfig creates Caffeine-backed CacheManager with "projectionsByName" cache
    - DynamicMetadataService interface exposes getProjection, getProjectionEntity, getFields, getAllProjectionNames, invalidateCache
    - DynamicMetadataServiceImpl loads projections via JPQL with JOIN FETCH to avoid N+1
    - JPA entities converted to immutable records before caching (no LazyInitializationException)
    - Cache preloaded at startup via @EventListener(ApplicationReadyEvent.class)
    - Cache invalidation via @CacheEvict clears all entries
    - Self-invocation avoided by using CacheManager.put() in preloadCache
    - All four field mapping types (DM, JM, CV, JP) correctly handled in toFieldMetadata
  </done>
</task>

</tasks>

<verification>
1. All 8 new/modified files exist at the correct paths under `modules_core/com.etendorx.das/`
2. Package structure: `com.etendorx.das.metadata`, `com.etendorx.das.metadata.models`, `com.etendorx.das.metadata.config`
3. `build.gradle` has `spring-boot-starter-cache` and `caffeine` dependencies
4. `FieldMappingType.fromCode("DM")` returns `DIRECT_MAPPING` (and so on for JM, CV, JP)
5. `DynamicMetadataServiceImpl` uses `EntityManager` for JPQL queries (not modifying generated repos)
6. `@EnableCaching` is on `MetadataCacheConfig` (not on `EtendorxDasApplication`)
7. No generated files in `modules_gen/` were modified
8. `./gradlew :com.etendorx.das:compileJava` compiles without errors
</verification>

<success_criteria>
- DynamicMetadataService interface and implementation exist with all 5 API methods
- Caffeine cache configured with 24h TTL and 500 max entries
- Projection metadata loaded at startup from DB via JPQL JOIN FETCH
- JPA entities transformed to immutable Java records before caching
- All 4 field mapping types have type-safe enum representation
- EntityMetadata includes restEndPoint and externalName for Phase 4 consumption
- Code compiles against existing project dependencies
</success_criteria>

<output>
After completion, create `.planning/phases/01-dynamic-metadata-service/01-01-SUMMARY.md`
</output>
