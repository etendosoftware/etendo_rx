---
phase: 01-dynamic-metadata-service
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - modules_core/com.etendorx.das/src/test/java/com/etendorx/das/unit/DynamicMetadataServiceTest.java
autonomous: true

must_haves:
  truths:
    - "Tests verify projection loading converts JPA entities to correct record structure"
    - "Tests verify cache serves repeated lookups without calling DB again"
    - "Tests verify cache miss triggers DB query"
    - "Tests verify invalid projection name returns empty Optional"
    - "Tests verify all four mapping types (DM, JM, CV, JP) produce correct FieldMetadata"
    - "Tests verify cache invalidation clears all entries"
    - "Tests verify getProjectionEntity navigates to correct entity within projection"
    - "Tests verify getFields returns fields for given entity ID"
  artifacts:
    - path: "modules_core/com.etendorx.das/src/test/java/com/etendorx/das/unit/DynamicMetadataServiceTest.java"
      provides: "Comprehensive unit tests for DynamicMetadataService"
      min_lines: 150
  key_links:
    - from: "DynamicMetadataServiceTest.java"
      to: "DynamicMetadataServiceImpl.java"
      via: "Direct instantiation with mocked EntityManager and CacheManager"
      pattern: "DynamicMetadataServiceImpl|@Mock.*EntityManager"
---

<objective>
Create comprehensive unit tests for DynamicMetadataService covering all scenarios: loading, caching, cache misses, invalid lookups, all field mapping types, cache invalidation, and sub-entity queries.

Purpose: Validate that the metadata service correctly transforms JPA entities into immutable records, handles all four field mapping types, and that the caching behavior works as expected. These tests provide a safety net for Phase 2-4 development.

Output: Test class with 8+ test methods covering all success criteria from Phase 1 roadmap.
</objective>

<execution_context>
@/Users/sebastianbarrozo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sebastianbarrozo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-dynamic-metadata-service/01-RESEARCH.md
@.planning/phases/01-dynamic-metadata-service/01-01-SUMMARY.md

Key source files created in Plan 01:
@modules_core/com.etendorx.das/src/main/java/com/etendorx/das/metadata/DynamicMetadataService.java
@modules_core/com.etendorx.das/src/main/java/com/etendorx/das/metadata/DynamicMetadataServiceImpl.java
@modules_core/com.etendorx.das/src/main/java/com/etendorx/das/metadata/models/ProjectionMetadata.java
@modules_core/com.etendorx.das/src/main/java/com/etendorx/das/metadata/models/EntityMetadata.java
@modules_core/com.etendorx.das/src/main/java/com/etendorx/das/metadata/models/FieldMetadata.java
@modules_core/com.etendorx.das/src/main/java/com/etendorx/das/metadata/models/FieldMappingType.java
@modules_core/com.etendorx.das/src/main/java/com/etendorx/das/metadata/config/MetadataCacheConfig.java

Existing JPA entities to mock:
@modules_gen/com.etendorx.entities/src/main/entities/com/etendoerp/etendorx/data/ETRXProjection.java
@modules_gen/com.etendorx.entities/src/main/entities/com/etendoerp/etendorx/data/ETRXProjectionEntity.java
@modules_gen/com.etendorx.entities/src/main/entities/com/etendoerp/etendorx/data/ETRXEntityField.java
@modules_gen/com.etendorx.entities/src/main/entities/com/etendoerp/etendorx/data/ETRXJavaMapping.java
@modules_gen/com.etendorx.entities/src/main/entities/com/etendoerp/etendorx/data/ConstantValue.java

Existing test pattern to follow:
@modules_core/com.etendorx.das/src/test/java/com/etendorx/das/unit/MappingUtilsImplTest.java
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create DynamicMetadataService unit tests</name>
  <files>
    modules_core/com.etendorx.das/src/test/java/com/etendorx/das/unit/DynamicMetadataServiceTest.java
  </files>
  <action>
    Create a unit test class using `@ExtendWith(MockitoExtension.class)` that tests `DynamicMetadataServiceImpl` with mocked `EntityManager` and `CacheManager`. Follow the existing test style in `MappingUtilsImplTest.java` (Mockito mocks, AAA pattern).

    **Test class setup:**
    - `@Mock EntityManager entityManager` - mock for JPQL queries
    - `@Mock CacheManager cacheManager` - mock for cache operations
    - `@Mock Cache cache` - mock for specific cache instance
    - `@Mock TypedQuery<ETRXProjection> typedQuery` - mock for JPQL query results
    - `DynamicMetadataServiceImpl service` - instantiated in `@BeforeEach` with mocked dependencies
    - In `@BeforeEach`: wire `when(cacheManager.getCache("projectionsByName")).thenReturn(cache)` and create the service via constructor

    **Helper method `createTestProjection(String name, String entityName, String fieldMappingType)`:**
    Creates a mock ETRXProjection with:
    - One ETRXProjectionEntity (with given name, mock Table for tableId, identity=false, restEndPoint=true)
    - One ETRXEntityField on that entity with the given fieldMappingType
    - For "JM" type: mock ETRXJavaMapping with qualifier "testQualifier"
    - For "CV" type: mock ConstantValue with defaultValue "testConstant"
    - For "JP" type: jsonpath set to "$.data.value"
    - For "DM" type: plain property mapping with property "testProperty"
    Use Mockito `mock()` and `when()` for JPA entities (they use Lombok @Getter/@Setter, so mock the getter methods).

    **Required test methods:**

    1. `testGetProjection_Found()` - Setup typedQuery to return a test projection. Call `service.getProjection("TestProjection")`. Assert: result is present, name matches, has 1 entity, entity has 1 field.

    2. `testGetProjection_NotFound()` - Setup typedQuery to return empty list. Call `service.getProjection("NonExistent")`. Assert: result is empty.

    3. `testGetProjectionEntity_Found()` - Setup typedQuery to return projection with entity named "Product". Call `service.getProjectionEntity("TestProjection", "Product")`. Assert: result is present, name is "Product".

    4. `testGetProjectionEntity_ProjectionNotFound()` - Setup typedQuery to return empty list. Call `service.getProjectionEntity("NonExistent", "Product")`. Assert: result is empty.

    5. `testGetProjectionEntity_EntityNotFound()` - Setup typedQuery to return projection with entity "Order". Call `service.getProjectionEntity("TestProjection", "NonExistent")`. Assert: result is empty.

    6. `testFieldMapping_DirectMapping()` - Create projection with "DM" field. Load via getProjection. Assert: field's fieldMapping is `FieldMappingType.DIRECT_MAPPING`, property is set, javaMappingQualifier/constantValue/jsonPath are null.

    7. `testFieldMapping_JavaMapping()` - Create projection with "JM" field and mock ETRXJavaMapping. Assert: fieldMapping is `JAVA_MAPPING`, javaMappingQualifier is "testQualifier".

    8. `testFieldMapping_ConstantValue()` - Create projection with "CV" field and mock ConstantValue. Assert: fieldMapping is `CONSTANT_VALUE`, constantValue is "testConstant".

    9. `testFieldMapping_JsonPath()` - Create projection with "JP" field with jsonpath "$.data.value". Assert: fieldMapping is `JSON_PATH`, jsonPath is "$.data.value".

    10. `testInvalidateCache()` - Call `service.invalidateCache()`. This method is annotated with `@CacheEvict` so in a unit test context (no Spring proxy), just verify the method executes without error. The caching behavior is an integration concern.

    11. `testFieldMappingType_FromCode()` - Test `FieldMappingType.fromCode()` for all 4 valid codes and verify `IllegalArgumentException` for unknown code "XX".

    **Mocking the EntityManager query chain:**
    ```java
    when(entityManager.createQuery(anyString(), eq(ETRXProjection.class))).thenReturn(typedQuery);
    when(typedQuery.setParameter(eq("name"), anyString())).thenReturn(typedQuery);
    when(typedQuery.getResultList()).thenReturn(List.of(testProjection));
    ```

    **Important mock details for JPA entities:**
    - `ETRXProjection`, `ETRXProjectionEntity`, `ETRXEntityField` use Lombok `@Getter/@Setter`, so mock them with `mock(ETRXProjection.class)` and `when(projection.getName()).thenReturn("TestProjection")`.
    - For `ETRXProjectionEntity.getTableEntity()`, return a mock `Table` object with `when(table.getId()).thenReturn("table-123")`.
    - The `Table` class is `org.openbravo.model.ad.datamodel.Table`.
    - For collections: `when(projection.getETRXProjectionEntityList()).thenReturn(List.of(entity))`.

    **Package:** `com.etendorx.das.unit`
    **Imports:** Use JUnit 5 (`org.junit.jupiter.api.*`), Mockito (`org.mockito.*`), AssertJ (`org.assertj.core.api.Assertions.assertThat`) if available, or JUnit assertions. Follow existing test pattern from MappingUtilsImplTest.java.
  </action>
  <verify>
    1. Test file exists at `modules_core/com.etendorx.das/src/test/java/com/etendorx/das/unit/DynamicMetadataServiceTest.java`
    2. Run: `./gradlew :com.etendorx.das:test --tests "com.etendorx.das.unit.DynamicMetadataServiceTest"` - all tests pass
    3. If the full test suite cannot run (due to application context issues), at minimum verify compilation: `./gradlew :com.etendorx.das:compileTestJava`
  </verify>
  <done>
    - 11 test methods covering all Phase 1 success criteria
    - Tests validate projection loading produces correct record structure
    - Tests validate all four field mapping types (DM, JM, CV, JP)
    - Tests validate empty results for non-existent projections/entities
    - Tests validate FieldMappingType enum parsing
    - Tests use Mockito mocks (no Spring context, no database)
    - All tests pass or compile cleanly
  </done>
</task>

<task type="auto">
  <name>Task 2: Verify full compilation and test execution</name>
  <files>
    modules_core/com.etendorx.das/build.gradle
  </files>
  <action>
    1. Run `./gradlew :com.etendorx.das:compileJava` to verify main source compiles.
    2. Run `./gradlew :com.etendorx.das:compileTestJava` to verify test source compiles.
    3. Run `./gradlew :com.etendorx.das:test --tests "com.etendorx.das.unit.DynamicMetadataServiceTest"` to execute the new tests.
    4. If any compilation errors occur, fix them:
       - Missing imports: add the correct import statements
       - Type mismatches: verify JPA entity getter names match what we mock (e.g., `getGRPC()` vs `isGRPC()`, `getIsmandatory()` vs `isMandatory()`)
       - Missing dependencies: verify build.gradle has required entries
    5. If tests fail, debug and fix:
       - Mock setup issues: ensure Mockito `when()` stubs match actual method calls
       - Null pointer exceptions: verify all required mock returns are configured
       - Assertion failures: verify expected values match actual conversion logic
    6. Ensure no existing tests are broken by the changes (run full test suite if feasible, otherwise at minimum run the unit test folder).

    **Do NOT modify build.gradle unless a missing dependency is identified.** The goal is validation and fixing, not adding features.
  </action>
  <verify>
    1. `./gradlew :com.etendorx.das:compileJava` succeeds with 0 errors
    2. `./gradlew :com.etendorx.das:compileTestJava` succeeds with 0 errors
    3. `./gradlew :com.etendorx.das:test --tests "com.etendorx.das.unit.DynamicMetadataServiceTest"` - all 11 tests pass (or however many survived debugging)
    4. No existing tests broken
  </verify>
  <done>
    - Main source compiles without errors
    - Test source compiles without errors
    - All DynamicMetadataService unit tests pass
    - No regressions in existing test suite
  </done>
</task>

</tasks>

<verification>
1. All unit tests pass: `./gradlew :com.etendorx.das:test --tests "com.etendorx.das.unit.DynamicMetadataServiceTest"`
2. Tests cover the 4 required scenarios from roadmap: loading, caching, cache miss, invalid projection name
3. Tests cover all 4 field mapping types (DM, JM, CV, JP)
4. Tests use mock repositories (no database dependency)
5. No existing tests broken by new code
</verification>

<success_criteria>
- 11 unit tests pass covering: projection loading, entity navigation, field mapping types (x4), cache miss, not-found scenarios (x3), cache invalidation, enum parsing
- Tests validate the full conversion chain: JPA entity -> immutable record
- Tests confirm FieldMappingType.fromCode() handles all valid codes and rejects invalid ones
- Compilation of both main and test sources succeeds
- No regressions in existing test suite
</success_criteria>

<output>
After completion, create `.planning/phases/01-dynamic-metadata-service/01-02-SUMMARY.md`
</output>
