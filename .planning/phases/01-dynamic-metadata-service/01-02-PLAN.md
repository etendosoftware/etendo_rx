---
phase: 01-dynamic-metadata-service
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - modules_core/com.etendorx.das/src/main/java/com/etendorx/das/metadata/config/MetadataCacheConfig.java
  - modules_core/com.etendorx.das/src/main/java/com/etendorx/das/metadata/DynamicMetadataServiceImpl.java
autonomous: true

must_haves:
  truths:
    - "Projection metadata can be loaded from etrx_projection, etrx_projection_entity, etrx_entity_field tables at runtime"
    - "Cache serves repeated lookups without additional DB queries"
    - "After cache invalidation, next projection query loads fresh data from DB"
    - "All projections are preloaded into cache at application startup"
  artifacts:
    - path: "modules_core/com.etendorx.das/src/main/java/com/etendorx/das/metadata/config/MetadataCacheConfig.java"
      provides: "Caffeine cache manager configuration"
      contains: "@EnableCaching"
    - path: "modules_core/com.etendorx.das/src/main/java/com/etendorx/das/metadata/DynamicMetadataServiceImpl.java"
      provides: "Service implementation with caching and DB loading"
      contains: "@Cacheable"
  key_links:
    - from: "DynamicMetadataServiceImpl.java"
      to: "EntityManager"
      via: "constructor injection + JPQL queries"
      pattern: "EntityManager|createQuery"
    - from: "DynamicMetadataServiceImpl.java"
      to: "ProjectionMetadata/EntityMetadata/FieldMetadata records"
      via: "toProjectionMetadata/toEntityMetadata/toFieldMetadata conversion methods"
      pattern: "toProjectionMetadata|toEntityMetadata|toFieldMetadata"
    - from: "DynamicMetadataServiceImpl.java"
      to: "MetadataCacheConfig"
      via: "Spring Cache abstraction (@Cacheable referencing cache names defined in config)"
      pattern: "@Cacheable.*projectionsByName"
    - from: "DynamicMetadataServiceImpl.preloadCache()"
      to: "CacheManager"
      via: "Programmatic cache.put() to populate cache at startup"
      pattern: "cache\\.put"
---

<objective>
Implement the MetadataCacheConfig and DynamicMetadataServiceImpl - the Caffeine cache configuration and the service that loads projection/entity/field metadata from the database, converts JPA entities to immutable records, and caches them.

Purpose: This is the runtime engine of the metadata service. Plan 01 created the types and interface; this plan provides the working implementation that all downstream phases (converter, repository, controller) will use.

Output: Working DynamicMetadataServiceImpl with JPQL-based loading, JPA-to-record conversion, Caffeine caching, startup preload, and cache invalidation.
</objective>

<execution_context>
@/Users/sebastianbarrozo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sebastianbarrozo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-dynamic-metadata-service/01-RESEARCH.md
@.planning/phases/01-dynamic-metadata-service/01-01-SUMMARY.md

Key source files from Plan 01:
@modules_core/com.etendorx.das/src/main/java/com/etendorx/das/metadata/DynamicMetadataService.java
@modules_core/com.etendorx.das/src/main/java/com/etendorx/das/metadata/models/ProjectionMetadata.java
@modules_core/com.etendorx.das/src/main/java/com/etendorx/das/metadata/models/EntityMetadata.java
@modules_core/com.etendorx.das/src/main/java/com/etendorx/das/metadata/models/FieldMetadata.java
@modules_core/com.etendorx.das/src/main/java/com/etendorx/das/metadata/models/FieldMappingType.java

Existing JPA entities (read, do not modify):
@modules_gen/com.etendorx.entities/src/main/entities/com/etendoerp/etendorx/data/ETRXProjection.java
@modules_gen/com.etendorx.entities/src/main/entities/com/etendoerp/etendorx/data/ETRXProjectionEntity.java
@modules_gen/com.etendorx.entities/src/main/entities/com/etendoerp/etendorx/data/ETRXEntityField.java
@modules_gen/com.etendorx.entities/src/main/entities/com/etendoerp/etendorx/data/ETRXJavaMapping.java
@modules_gen/com.etendorx.entities/src/main/entities/com/etendoerp/etendorx/data/ConstantValue.java
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create MetadataCacheConfig</name>
  <files>
    modules_core/com.etendorx.das/src/main/java/com/etendorx/das/metadata/config/MetadataCacheConfig.java
  </files>
  <action>
    Create `MetadataCacheConfig.java` in `com.etendorx.das.metadata.config`:
    ```java
    @Configuration
    @EnableCaching
    public class MetadataCacheConfig {
        @Bean
        public CacheManager cacheManager() {
            CaffeineCacheManager cacheManager = new CaffeineCacheManager(
                "projections", "projectionsByName"
            );
            cacheManager.setCaffeine(Caffeine.newBuilder()
                .maximumSize(500)
                .expireAfterWrite(Duration.ofHours(24))
                .recordStats());
            return cacheManager;
        }
    }
    ```
    Two cache regions: `projections` for all-projections map, `projectionsByName` for individual lookups. Use 24h expiry as safety net (primary invalidation is manual). Import from `com.github.ben-manes.caffeine.cache.Caffeine`, `org.springframework.cache.CacheManager`, `org.springframework.cache.caffeine.CaffeineCacheManager`, `java.time.Duration`.
  </action>
  <verify>
    File exists at specified path. Contains `@Configuration`, `@EnableCaching`, `CaffeineCacheManager`, and both cache names "projections" and "projectionsByName".
  </verify>
  <done>
    - MetadataCacheConfig creates Caffeine-backed CacheManager
    - Two cache regions defined: "projections" and "projectionsByName"
    - 24h TTL and 500 max entries configured
  </done>
</task>

<task type="auto">
  <name>Task 2: Create DynamicMetadataServiceImpl</name>
  <files>
    modules_core/com.etendorx.das/src/main/java/com/etendorx/das/metadata/DynamicMetadataServiceImpl.java
  </files>
  <action>
    Create `DynamicMetadataServiceImpl.java` in `com.etendorx.das.metadata`.

    **Dependencies (constructor injection):**
    - `EntityManager entityManager` - for JPQL queries against JPA entities
    - `CacheManager cacheManager` - for programmatic cache population at startup

    **Class annotations:** `@Service`, `@Slf4j`

    **Method: `preloadCache()`** - annotated with `@EventListener(ApplicationReadyEvent.class)`:
    1. Execute JPQL: `"SELECT DISTINCT p FROM ETRX_Projection p LEFT JOIN FETCH p.eTRXProjectionEntityList"` to load all projections with their entities in one query.
    2. For each projection, iterate its entity list. For each entity, call `Hibernate.initialize(entity.getETRXEntityFieldList())` to eagerly load fields within the open session. For each field, call `Hibernate.initialize()` on `field.getJavaMapping()`, `field.getEtrxConstantValue()`, and `field.getEtrxProjectionEntityRelated()` (only if not null).
    3. Convert each ETRXProjection to a `ProjectionMetadata` record via `toProjectionMetadata()`.
    4. Put each record into the cache programmatically: `cacheManager.getCache("projectionsByName").put(metadata.name(), metadata)`.
    5. Log the count of loaded projections.

    Use `@EventListener(ApplicationReadyEvent.class)` (not `@PostConstruct`) because cache proxies are fully initialized at ApplicationReadyEvent time. Populate cache programmatically via `CacheManager.put()` (not via self-invocation of `@Cacheable` methods, which would bypass the proxy).

    **Method: `getProjection(String name)`** - annotated with `@Override`, `@Cacheable(value = "projectionsByName", key = "#name")`:
    1. Log cache miss at debug level.
    2. Execute JPQL: `"SELECT DISTINCT p FROM ETRX_Projection p LEFT JOIN FETCH p.eTRXProjectionEntityList e LEFT JOIN FETCH e.eTRXEntityFieldList WHERE p.name = :name"` with parameter binding.
    3. If results empty, return `Optional.empty()`.
    4. For the first result, initialize lazy relationships on each field (same pattern as preloadCache: `Hibernate.initialize()` for javaMapping, constantValue, relatedProjectionEntity).
    5. Convert to `ProjectionMetadata` record and return wrapped in `Optional.of()`.

    **Method: `getProjectionEntity(String projectionName, String entityName)`** - `@Override`:
    Delegate to `getProjection(projectionName).flatMap(p -> p.findEntity(entityName))`.

    **Method: `getFields(String projectionEntityId)`** - `@Override`:
    1. Get the "projectionsByName" cache from cacheManager.
    2. Get the native Caffeine cache via `cache.getNativeCache()` and cast to `com.github.ben-manes.caffeine.cache.Cache<?, ?>`.
    3. Iterate all cached values, unwrap each (handling Spring Cache Optional wrapping), and search for an EntityMetadata with matching ID.
    4. If found, return `entity.fields()`.
    5. If not found in cache, fall back to `loadFieldsFromDb(projectionEntityId)`.

    **Method: `getAllProjectionNames()`** - `@Override`:
    1. Get "projectionsByName" native cache.
    2. Return the key set mapped to strings.
    3. Return `Set.of()` if cache is unavailable.

    **Method: `invalidateCache()`** - `@Override`, annotated with `@CacheEvict(value = "projectionsByName", allEntries = true)`:
    Log cache invalidation at info level.

    **Private helper: `toProjectionMetadata(ETRXProjection projection)`:**
    Map `projection.getId()`, `projection.getName()`, `projection.getDescription()`, `projection.getGRPC()` (the getter may be `isGRPC()` - check the entity source), and convert entity list via `toEntityMetadata`.

    **Private helper: `toEntityMetadata(ETRXProjectionEntity entity)`:**
    Map `entity.getId()`, `entity.getName()`, `entity.getTableEntity().getId()` for tableId, `entity.getMappingType()`, `entity.getIdentity()` (may be `isIdentity()`), `entity.getRestEndPoint()` (may be `isRestEndPoint()`), `entity.getExternalName()`, and convert field list via `toFieldMetadata`.

    **Private helper: `toFieldMetadata(ETRXEntityField field)`:**
    1. Parse `FieldMappingType.fromCode(field.getFieldMapping())`.
    2. Extract common fields: `field.getId()`, `field.getName()`, `field.getProperty()`, `field.getIsmandatory()` (boolean), `field.getIdentifiesUnivocally()`, `field.getLine()`.
    3. Extract mapping-type-specific fields (all null-safe):
       - `field.getJavaMapping() != null ? field.getJavaMapping().getQualifier() : null` for javaMappingQualifier
       - `field.getEtrxConstantValue() != null ? field.getEtrxConstantValue().getDefaultValue() : null` for constantValue
       - `field.getJsonpath()` for jsonPath
       - `field.getEtrxProjectionEntityRelated() != null ? field.getEtrxProjectionEntityRelated().getId() : null` for relatedProjectionEntityId
       - `field.getCreateRelated()` (boolean) for createRelated
    4. Construct and return `new FieldMetadata(...)`.

    **Private helper: `unwrapCacheValue(Object value)`:**
    Handle Spring Cache wrapping: if value is `Optional`, call `.orElse(null)` and cast; if value is `ProjectionMetadata`, cast directly; otherwise return null.

    **Private helper: `loadFieldsFromDb(String projectionEntityId)`:**
    Execute JPQL: `"SELECT f FROM ETRX_EntityField f LEFT JOIN FETCH f.javaMapping LEFT JOIN FETCH f.etrxConstantValue LEFT JOIN FETCH f.etrxProjectionEntityRelated WHERE f.eTRXProjectionEntity.id = :entityId"` with parameter binding. Convert results via `toFieldMetadata()` and return as list. Return empty list if no results.

    **Imports needed:** `jakarta.persistence.EntityManager`, `jakarta.persistence.TypedQuery`, `org.hibernate.Hibernate`, `org.springframework.cache.Cache`, `org.springframework.cache.CacheManager`, `org.springframework.cache.annotation.Cacheable`, `org.springframework.cache.annotation.CacheEvict`, `org.springframework.boot.context.event.ApplicationReadyEvent`, `org.springframework.context.event.EventListener`, `org.springframework.stereotype.Service`, `lombok.extern.slf4j.Slf4j`, `java.util.*`, `java.util.stream.Collectors`, and the model/entity imports.
  </action>
  <verify>
    1. File exists at specified path.
    2. Contains `@Service`, `@Slf4j`, `@Cacheable`, `@CacheEvict`, `@EventListener(ApplicationReadyEvent.class)`.
    3. Contains all 5 interface methods implemented.
    4. Contains all 5 private helpers: `toProjectionMetadata`, `toEntityMetadata`, `toFieldMetadata`, `unwrapCacheValue`, `loadFieldsFromDb`.
    5. Run `./gradlew :com.etendorx.das:compileJava` to verify compilation succeeds.
  </verify>
  <done>
    - DynamicMetadataServiceImpl loads projections via JPQL with JOIN FETCH to avoid N+1
    - JPA entities converted to immutable records before caching (no LazyInitializationException)
    - Cache preloaded at startup via @EventListener(ApplicationReadyEvent.class)
    - Cache populated programmatically via CacheManager.put() (avoids proxy self-invocation)
    - @Cacheable on getProjection() for cache-miss loading
    - Cache invalidation via @CacheEvict clears all entries
    - All four field mapping types (DM, JM, CV, JP) correctly handled in toFieldMetadata
    - Compilation succeeds with `./gradlew :com.etendorx.das:compileJava`
  </done>
</task>

</tasks>

<verification>
1. Both files exist at the correct paths under `modules_core/com.etendorx.das/`
2. Package structure: `com.etendorx.das.metadata`, `com.etendorx.das.metadata.config`
3. `@EnableCaching` is on `MetadataCacheConfig` (not on `EtendorxDasApplication`)
4. `DynamicMetadataServiceImpl` uses `EntityManager` for JPQL queries (not modifying generated repos)
5. No generated files in `modules_gen/` were modified
6. `./gradlew :com.etendorx.das:compileJava` compiles without errors
</verification>

<success_criteria>
- MetadataCacheConfig creates Caffeine-backed CacheManager with "projectionsByName" cache
- DynamicMetadataServiceImpl implements all 5 interface methods
- JPQL JOIN FETCH loads entire projection hierarchy efficiently
- JPA entities transformed to immutable Java records before caching
- Startup preload uses ApplicationReadyEvent + programmatic cache.put()
- Code compiles against existing project dependencies
</success_criteria>

<output>
After completion, create `.planning/phases/01-dynamic-metadata-service/01-02-SUMMARY.md`
</output>
