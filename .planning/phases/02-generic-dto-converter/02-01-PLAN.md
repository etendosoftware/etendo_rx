---
phase: 02-generic-dto-converter
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - modules_core/com.etendorx.das/src/main/java/com/etendorx/das/converter/FieldConversionStrategy.java
  - modules_core/com.etendorx.das/src/main/java/com/etendorx/das/converter/PropertyAccessorService.java
  - modules_core/com.etendorx.das/src/main/java/com/etendorx/das/converter/ConversionContext.java
  - modules_core/com.etendorx.das/src/main/java/com/etendorx/das/converter/ConversionException.java
  - modules_core/com.etendorx.das/src/main/java/com/etendorx/das/converter/strategy/DirectMappingStrategy.java
  - modules_core/com.etendorx.das/src/main/java/com/etendorx/das/converter/strategy/ConstantValueStrategy.java
  - modules_core/com.etendorx.das/src/main/java/com/etendorx/das/converter/strategy/ComputedMappingStrategy.java
  - modules_core/com.etendorx.das/build.gradle
autonomous: true

must_haves:
  truths:
    - "FieldConversionStrategy interface defines readField and writeField contracts"
    - "PropertyAccessorService can read and write nested dot-notation properties on any bean"
    - "ConversionContext tracks visited entities to prevent infinite recursion"
    - "DirectMappingStrategy reads entity properties via PropertyAccessorService and applies MappingUtils.handleBaseObject()"
    - "DirectMappingStrategy writes values to entity properties with type coercion for dates"
    - "ConstantValueStrategy reads constant values from DB via MappingUtils.constantValue()"
    - "ComputedMappingStrategy delegates to ConstantValueStrategy (CM is alias for CV)"
  artifacts:
    - path: "modules_core/com.etendorx.das/src/main/java/com/etendorx/das/converter/FieldConversionStrategy.java"
      provides: "Strategy interface with readField/writeField"
      contains: "interface FieldConversionStrategy"
    - path: "modules_core/com.etendorx.das/src/main/java/com/etendorx/das/converter/PropertyAccessorService.java"
      provides: "Nested property access via BeanUtils"
      contains: "getNestedProperty"
    - path: "modules_core/com.etendorx.das/src/main/java/com/etendorx/das/converter/ConversionContext.java"
      provides: "Cycle detection for recursive EM conversions"
      contains: "isVisited"
    - path: "modules_core/com.etendorx.das/src/main/java/com/etendorx/das/converter/strategy/DirectMappingStrategy.java"
      provides: "DM field read/write"
      contains: "class DirectMappingStrategy"
    - path: "modules_core/com.etendorx.das/src/main/java/com/etendorx/das/converter/strategy/ConstantValueStrategy.java"
      provides: "CV field read (constant from DB)"
      contains: "class ConstantValueStrategy"
    - path: "modules_core/com.etendorx.das/src/main/java/com/etendorx/das/converter/strategy/ComputedMappingStrategy.java"
      provides: "CM field read (delegates to CV)"
      contains: "class ComputedMappingStrategy"
  key_links:
    - from: "DirectMappingStrategy"
      to: "PropertyAccessorService"
      via: "constructor injection"
      pattern: "propertyAccessorService\\.getNestedProperty"
    - from: "DirectMappingStrategy"
      to: "MappingUtils"
      via: "constructor injection for handleBaseObject"
      pattern: "mappingUtils\\.handleBaseObject"
    - from: "ConstantValueStrategy"
      to: "MappingUtils"
      via: "constructor injection for constantValue"
      pattern: "mappingUtils\\.constantValue"
---

<objective>
Create the foundation layer for the dynamic DTO converter: the strategy interface, property accessor service, conversion context for cycle detection, and the three simple field strategies (DM, CV, CM).

Purpose: Establishes the core abstractions that all field mapping strategies implement, plus the three simplest strategies that cover the majority of fields in typical projections. Complex strategies (EM, JM, JP) build on this foundation in Plan 02.

Output: 7 Java files defining the converter framework + 3 working strategies for simple field types.
</objective>

<execution_context>
@/Users/sebastianbarrozo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sebastianbarrozo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-generic-dto-converter/02-CONTEXT.md
@.planning/phases/02-generic-dto-converter/02-RESEARCH.md
@modules_core/com.etendorx.das/src/main/java/com/etendorx/das/metadata/models/FieldMetadata.java
@modules_core/com.etendorx.das/src/main/java/com/etendorx/das/metadata/models/EntityMetadata.java
@modules_core/com.etendorx.das/src/main/java/com/etendorx/das/metadata/models/FieldMappingType.java
@modules_core/com.etendorx.das/src/main/java/com/etendorx/das/utils/MappingUtilsImpl.java
@modules_core/com.etendorx.das/build.gradle
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create converter foundation classes and add BeanUtils dependency</name>
  <files>
    modules_core/com.etendorx.das/build.gradle
    modules_core/com.etendorx.das/src/main/java/com/etendorx/das/converter/FieldConversionStrategy.java
    modules_core/com.etendorx.das/src/main/java/com/etendorx/das/converter/PropertyAccessorService.java
    modules_core/com.etendorx.das/src/main/java/com/etendorx/das/converter/ConversionContext.java
    modules_core/com.etendorx.das/src/main/java/com/etendorx/das/converter/ConversionException.java
  </files>
  <action>
    1. **Add Apache Commons BeanUtils dependency** to `modules_core/com.etendorx.das/build.gradle`:
       - Add `implementation 'commons-beanutils:commons-beanutils:1.9.4'` in the dependencies block (after the existing commons-lang3 line).
       - BeanUtils is NOT currently in the project -- it must be added explicitly.

    2. **Create `FieldConversionStrategy.java`** in package `com.etendorx.das.converter`:
       ```java
       public interface FieldConversionStrategy {
           Object readField(Object entity, FieldMetadata field, ConversionContext ctx);
           void writeField(Object entity, Object value, FieldMetadata field, ConversionContext ctx);
       }
       ```
       - Import `com.etendorx.das.metadata.models.FieldMetadata`.
       - This is the contract all 6 strategies implement. readField extracts a value from entity; writeField sets a value on entity.

    3. **Create `ConversionContext.java`** in package `com.etendorx.das.converter`:
       - NOT a Spring component -- instantiated per-conversion as `new ConversionContext()`.
       - Contains a `Set<String> visitedEntityKeys` (HashSet).
       - Method `boolean isVisited(Object entity)`:
         - Build key as `entity.getClass().getName() + ":" + getEntityId(entity)`.
         - If key already in set, return `true` (cycle detected).
         - If key NOT in set, add it and return `false`.
       - Private method `String getEntityId(Object entity)`:
         - If `entity instanceof BaseRXObject`, return `((BaseRXObject) entity).get_identifier()`.
         - Else return `String.valueOf(System.identityHashCode(entity))` as fallback.
       - Import `com.etendorx.entities.entities.BaseRXObject`.
       - Also store a `Map<String, Object> fullDto` field (with getter/setter) so JM write strategies can access the complete DTO map when needed. Initialize to null.

    4. **Create `ConversionException.java`** in package `com.etendorx.das.converter`:
       - A simple `RuntimeException` subclass with constructors: `ConversionException(String message)` and `ConversionException(String message, Throwable cause)`.

    5. **Create `PropertyAccessorService.java`** as `@Component` in package `com.etendorx.das.converter`:
       - Method `Object getNestedProperty(Object bean, String propertyPath)`:
         - Use `org.apache.commons.beanutils.PropertyUtils.getNestedProperty(bean, propertyPath)`.
         - Catch ALL exceptions (NoSuchMethodException, IllegalAccessException, InvocationTargetException, NestedNullException) and return `null`. This replicates the generated converter behavior where null intermediate objects (e.g., entity.role is null when reading entity.role.id) return null instead of throwing NPE.
         - Log the exception at DEBUG level.
       - Method `void setNestedProperty(Object bean, String propertyPath, Object value)`:
         - Use `org.apache.commons.beanutils.PropertyUtils.setNestedProperty(bean, propertyPath, value)`.
         - Catch exceptions and wrap in `ConversionException("Cannot set property: " + propertyPath, e)`.
       - Use `@Slf4j` (Lombok).
  </action>
  <verify>
    - All 5 files exist in expected paths.
    - `build.gradle` contains `commons-beanutils` dependency.
    - `FieldConversionStrategy` has both `readField` and `writeField` methods.
    - `PropertyAccessorService` imports `org.apache.commons.beanutils.PropertyUtils`.
    - `ConversionContext` has `isVisited` method and `fullDto` field.
  </verify>
  <done>Foundation classes compile-ready: strategy interface, property accessor with BeanUtils, cycle detection context, and conversion exception.</done>
</task>

<task type="auto">
  <name>Task 2: Create DirectMapping, ConstantValue, and ComputedMapping strategies</name>
  <files>
    modules_core/com.etendorx.das/src/main/java/com/etendorx/das/converter/strategy/DirectMappingStrategy.java
    modules_core/com.etendorx.das/src/main/java/com/etendorx/das/converter/strategy/ConstantValueStrategy.java
    modules_core/com.etendorx.das/src/main/java/com/etendorx/das/converter/strategy/ComputedMappingStrategy.java
  </files>
  <action>
    1. **Create `DirectMappingStrategy.java`** as `@Component` in package `com.etendorx.das.converter.strategy`:
       - Implements `FieldConversionStrategy`.
       - Constructor-inject `PropertyAccessorService` and `MappingUtils` (the interface from `com.etendorx.entities.entities.mappings.MappingUtils`).
       - `readField`:
         - Get raw value: `Object rawValue = propertyAccessorService.getNestedProperty(entity, field.property())`.
         - If rawValue is null, return null.
         - Return `mappingUtils.handleBaseObject(rawValue)`.
         - This replicates exactly what generated FieldConverterRead does: read property, then pass through handleBaseObject which converts BaseSerializableObject to identifier, Date to formatted string, PersistentBag to List.
       - `writeField`:
         - If value is null: `propertyAccessorService.setNestedProperty(entity, field.property(), null)` and return.
         - Handle Date type coercion: if the property path on the entity is a `Date` type and value is a `String`, use `mappingUtils.parseDate((String) value)` to convert. To detect if the target is Date: use `PropertyUtils.getPropertyType(entity, field.property())` from BeanUtils (wrap in try/catch, if it fails just set raw value).
         - Handle numeric coercion: if target type is `Long` and value is `Integer`, convert. If target is `BigDecimal` and value is `Number`, convert. Use `org.apache.commons.lang3.math.NumberUtils` or simple instanceof checks.
         - Otherwise set the value directly: `propertyAccessorService.setNestedProperty(entity, field.property(), value)`.
       - Use `@Slf4j`.

    2. **Create `ConstantValueStrategy.java`** as `@Component` in package `com.etendorx.das.converter.strategy`:
       - Implements `FieldConversionStrategy`.
       - Constructor-inject `MappingUtils`.
       - `readField`:
         - Return `mappingUtils.constantValue(field.constantValue())`.
         - If `field.constantValue()` is null, return null.
       - `writeField`:
         - No-op (constants are read-only). Just return without doing anything. Generated converters never write CV fields.

    3. **Create `ComputedMappingStrategy.java`** as `@Component` in package `com.etendorx.das.converter.strategy`:
       - Implements `FieldConversionStrategy`.
       - Constructor-inject `ConstantValueStrategy`.
       - `readField`: Delegate to `constantValueStrategy.readField(entity, field, ctx)`.
       - `writeField`: Delegate to `constantValueStrategy.writeField(entity, field, ctx)` (which is no-op).
       - CM (Constant Mapping) is functionally identical to CV (Constant Value) in the current codebase.
  </action>
  <verify>
    - All 3 strategy files exist in `com.etendorx.das.converter.strategy` package.
    - `DirectMappingStrategy` uses `propertyAccessorService.getNestedProperty()` for reads and `mappingUtils.handleBaseObject()` for type coercion.
    - `DirectMappingStrategy` write path handles Date and numeric type coercion.
    - `ConstantValueStrategy` read uses `mappingUtils.constantValue()`.
    - `ComputedMappingStrategy` delegates to `ConstantValueStrategy`.
    - All are `@Component` annotated Spring beans.
  </verify>
  <done>Three simple strategies (DM, CV, CM) implement FieldConversionStrategy with correct read/write behavior matching generated converters.</done>
</task>

</tasks>

<verification>
- All 8 files created in correct packages under `com.etendorx.das.converter` and `com.etendorx.das.converter.strategy`.
- `build.gradle` has `commons-beanutils:1.9.4` dependency added.
- `FieldConversionStrategy` interface has `readField` and `writeField` signatures.
- `PropertyAccessorService` returns null (not throws) for null intermediate properties.
- `DirectMappingStrategy` chains `getNestedProperty` -> `handleBaseObject` on read.
- `ConstantValueStrategy` uses `mappingUtils.constantValue(field.constantValue())` on read.
- `ConversionContext.isVisited()` tracks entities by class+id key.
</verification>

<success_criteria>
- Foundation classes and 3 strategies created and syntactically correct.
- Strategy pattern established: all strategies implement same interface.
- PropertyAccessorService provides null-safe nested property access via BeanUtils.
- ConversionContext ready for cycle detection in EM conversions (Plan 02).
- DM read replicates handleBaseObject behavior. DM write handles Date/numeric coercion.
- CV read returns constant from DB. CM delegates to CV.
</success_criteria>

<output>
After completion, create `.planning/phases/02-generic-dto-converter/02-01-SUMMARY.md`
</output>
