---
phase: 02-generic-dto-converter
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - modules_core/com.etendorx.das/src/main/java/com/etendorx/das/converter/strategy/EntityMappingStrategy.java
  - modules_core/com.etendorx.das/src/main/java/com/etendorx/das/converter/strategy/JavaMappingStrategy.java
  - modules_core/com.etendorx.das/src/main/java/com/etendorx/das/converter/strategy/JsonPathStrategy.java
  - modules_core/com.etendorx.das/src/main/java/com/etendorx/das/converter/DynamicDTOConverter.java
autonomous: true

must_haves:
  truths:
    - "EntityMappingStrategy recursively converts related entities into nested Maps on read"
    - "EntityMappingStrategy detects cycles and returns id+identifier stub for already-visited entities"
    - "EntityMappingStrategy resolves entity references by externalId on write using ExternalIdService"
    - "JavaMappingStrategy delegates read to DTOReadMapping Spring bean resolved by qualifier"
    - "JavaMappingStrategy delegates write to DTOWriteMapping Spring bean resolved by qualifier"
    - "JsonPathStrategy extracts field values from JSON string properties using JsonPath expressions"
    - "DynamicDTOConverter.convertToMap converts any JPA entity to Map using projection metadata"
    - "DynamicDTOConverter.convertToEntity populates a JPA entity from Map with audit field integration"
    - "DynamicDTOConverter validates mandatory fields on write and throws clear errors"
  artifacts:
    - path: "modules_core/com.etendorx.das/src/main/java/com/etendorx/das/converter/strategy/EntityMappingStrategy.java"
      provides: "EM field read/write with cycle detection and ExternalId resolution"
      contains: "class EntityMappingStrategy"
    - path: "modules_core/com.etendorx.das/src/main/java/com/etendorx/das/converter/strategy/JavaMappingStrategy.java"
      provides: "JM field read/write via Spring bean qualifier"
      contains: "class JavaMappingStrategy"
    - path: "modules_core/com.etendorx.das/src/main/java/com/etendorx/das/converter/strategy/JsonPathStrategy.java"
      provides: "JP field extraction from JSON string"
      contains: "class JsonPathStrategy"
    - path: "modules_core/com.etendorx.das/src/main/java/com/etendorx/das/converter/DynamicDTOConverter.java"
      provides: "Main orchestrator for bidirectional entity-map conversion"
      exports: ["convertToMap", "convertToEntity"]
  key_links:
    - from: "DynamicDTOConverter"
      to: "FieldConversionStrategy implementations"
      via: "strategy map by FieldMappingType"
      pattern: "strategyMap\\.get\\(field\\.fieldMapping\\(\\)\\)"
    - from: "DynamicDTOConverter"
      to: "DynamicMetadataService"
      via: "getFields for related entities in EM"
      pattern: "metadataService"
    - from: "EntityMappingStrategy"
      to: "DynamicDTOConverter"
      via: "recursive convertToMap for nested objects"
      pattern: "dynamicDTOConverter\\.convertToMap"
    - from: "EntityMappingStrategy"
      to: "ExternalIdService"
      via: "convertExternalToInternalId for write"
      pattern: "externalIdService\\.convertExternalToInternalId"
    - from: "DynamicDTOConverter.convertToEntity"
      to: "AuditServiceInterceptor"
      via: "setAuditValues after field population"
      pattern: "auditServiceInterceptor\\.setAuditValues"
---

<objective>
Create the three complex field strategies (EM, JM, JP) and the DynamicDTOConverter orchestrator that ties all 6 strategies together for bidirectional entity-to-map conversion.

Purpose: This is the core of Phase 2 -- the converter that replaces generated `*DTOConverter` classes. It uses Phase 1's metadata to determine which strategy applies to each field, orchestrates conversion, handles audit fields, and validates mandatory fields on write.

Output: 4 Java files -- 3 complex strategies + the main converter orchestrator.
</objective>

<execution_context>
@/Users/sebastianbarrozo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sebastianbarrozo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-generic-dto-converter/02-CONTEXT.md
@.planning/phases/02-generic-dto-converter/02-RESEARCH.md
@.planning/phases/02-generic-dto-converter/02-01-SUMMARY.md

Key existing code to reference:
@modules_core/com.etendorx.das/src/main/java/com/etendorx/das/metadata/DynamicMetadataService.java
@modules_core/com.etendorx.das/src/main/java/com/etendorx/das/metadata/models/FieldMetadata.java
@modules_core/com.etendorx.das/src/main/java/com/etendorx/das/metadata/models/EntityMetadata.java
@modules_core/com.etendorx.das/src/main/java/com/etendorx/das/metadata/models/ProjectionMetadata.java
@modules_core/com.etendorx.das/src/main/java/com/etendorx/das/metadata/models/FieldMappingType.java
@modules_core/com.etendorx.das/src/main/java/com/etendorx/das/externalid/ExternalIdServiceImpl.java
@modules_core/com.etendorx.das/src/main/java/com/etendorx/das/hibernate_interceptor/AuditServiceInterceptorImpl.java
@modules_core/com.etendorx.das/src/main/java/com/etendorx/das/utils/MappingUtilsImpl.java
@libs/com.etendorx.das_core/src/main/java/com/etendorx/entities/mapper/lib/DTOReadMapping.java
@libs/com.etendorx.das_core/src/main/java/com/etendorx/entities/mapper/lib/DTOWriteMapping.java
@libs/com.etendorx.das_core/src/main/java/com/etendorx/entities/mapper/lib/ExternalIdService.java
@libs/com.etendorx.das_core/src/main/java/com/etendorx/entities/mapper/lib/JsonPathConverterBase.java
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create EntityMapping, JavaMapping, and JsonPath strategies</name>
  <files>
    modules_core/com.etendorx.das/src/main/java/com/etendorx/das/converter/strategy/EntityMappingStrategy.java
    modules_core/com.etendorx.das/src/main/java/com/etendorx/das/converter/strategy/JavaMappingStrategy.java
    modules_core/com.etendorx.das/src/main/java/com/etendorx/das/converter/strategy/JsonPathStrategy.java
  </files>
  <action>
    **IMPORTANT DESIGN NOTE:** EntityMappingStrategy has a circular dependency with DynamicDTOConverter (EM read calls back to converter for recursive conversion). Resolve this via `@Lazy` injection or by injecting `ApplicationContext` and looking up the converter bean at runtime. Prefer `@Lazy` on the DynamicDTOConverter dependency.

    1. **Create `EntityMappingStrategy.java`** as `@Component` in package `com.etendorx.das.converter.strategy`:
       - Implements `FieldConversionStrategy`.
       - Constructor-inject:
         - `PropertyAccessorService` (from Plan 01)
         - `DynamicMetadataService` (from Phase 1)
         - `ExternalIdService` (existing `com.etendorx.entities.mapper.lib.ExternalIdService` interface)
         - `EntityManager` (jakarta.persistence)
         - `@Lazy DynamicDTOConverter` (to break circular dependency -- this bean is created in Task 2)

       - `readField(Object entity, FieldMetadata field, ConversionContext ctx)`:
         - Get related entity: `Object relatedEntity = propertyAccessorService.getNestedProperty(entity, field.property())`.
         - If relatedEntity is null, return null.
         - **Cycle detection**: If `ctx.isVisited(relatedEntity)` returns true, return a stub Map:
           ```java
           Map<String, Object> stub = new HashMap<>();
           if (relatedEntity instanceof BaseRXObject rxObj) {
               stub.put("id", rxObj.getId());
               stub.put("_identifier", rxObj.get_identifier());
           }
           return stub;
           ```
         - **Handle one-to-many (List)**: If relatedEntity is a `Collection`, iterate and recursively convert each element. Return `List<Map<String, Object>>`. Check cycle detection per element.
         - **Normal case (many-to-one)**: Look up the related entity's metadata using `field.relatedProjectionEntityId()`. Use DynamicMetadataService: iterate all projections via `getAllProjectionNames()`, then for each projection, check its entities to find one with id matching `field.relatedProjectionEntityId()`. Extract that EntityMetadata and its fields.
           - If related metadata not found, fall back to returning just id+identifier stub.
           - If found, recursively call `dynamicDTOConverter.convertToMap(relatedEntity, relatedEntityMetadata, relatedEntityMetadata.fields(), ctx)`.
         - IMPORTANT: The `convertToMap` method on DynamicDTOConverter must accept a `ConversionContext` parameter to propagate cycle detection state.

       - `writeField(Object entity, Object value, FieldMetadata field, ConversionContext ctx)`:
         - If value is null, set property to null and return.
         - If value is a `Map`: extract "id" from the map: `String referenceId = (String) ((Map) value).get("id")`.
         - If value is a `String`: treat it as the ID directly: `String referenceId = (String) value`.
         - Resolve the reference:
           1. Look up related EntityMetadata via `field.relatedProjectionEntityId()` (same approach as read).
           2. Get the tableId from the related EntityMetadata.
           3. Call `externalIdService.convertExternalToInternalId(tableId, referenceId)` to resolve external ID to internal UUID.
           4. Use `entityManager.find(Class, internalId)` to load the related entity. The entity Class needs to be resolved -- use `entityManager.getMetamodel()` to find the entity class for the table, or iterate Hibernate metamodel. As a pragmatic approach: use `entityManager.createQuery("SELECT e FROM " + entityMetadata.name() + " e WHERE e.id = :id").setParameter("id", internalId).getSingleResult()`. If the entity name in EntityMetadata doesn't match JPA entity name, fall back to setting the raw ID.
           5. Set on parent entity: `propertyAccessorService.setNestedProperty(entity, field.property(), relatedEntity)`.

    2. **Create `JavaMappingStrategy.java`** as `@Component` in package `com.etendorx.das.converter.strategy`:
       - Implements `FieldConversionStrategy`.
       - Constructor-inject `ApplicationContext` (Spring).
       - `readField`:
         - Get qualifier: `String qualifier = field.javaMappingQualifier()`.
         - If qualifier is null or blank, log warning and return null.
         - Resolve bean: `DTOReadMapping<?> mapper = applicationContext.getBean(qualifier, DTOReadMapping.class)`.
         - Call: `return mapper.map(entity)`. Note: DTOReadMapping.map() takes the full entity, not a single field value. Cast entity to correct type -- since DTOReadMapping is generic `<T>`, use raw type cast.
         - Wrap in try-catch: if bean not found (NoSuchBeanDefinitionException), log error and return null.
       - `writeField`:
         - Get qualifier: `String qualifier = field.javaMappingQualifier()`.
         - If qualifier is null or blank, return (no-op).
         - Resolve bean: `DTOWriteMapping mapper = applicationContext.getBean(qualifier, DTOWriteMapping.class)`.
         - **KEY DESIGN DECISION**: DTOWriteMapping.map(entity, dto) expects the full DTO object, not a single field value. Get the full DTO from `ctx.getFullDto()`. If fullDto is null, log warning and return.
         - Call: `mapper.map(entity, ctx.getFullDto())`. Use raw types since the generic types vary per mapping.
         - Wrap in try-catch: if bean not found, log error and return.

    3. **Create `JsonPathStrategy.java`** as `@Component` in package `com.etendorx.das.converter.strategy`:
       - Implements `FieldConversionStrategy`.
       - Constructor-inject `PropertyAccessorService` and `MappingUtils`.
       - `readField`:
         - Get the source property (a JSON string field on the entity): `Object rawJson = propertyAccessorService.getNestedProperty(entity, field.property())`.
         - If rawJson is null, return null.
         - Convert to String: `String jsonString = rawJson.toString()`.
         - Get the JsonPath expression: `String path = field.jsonPath()`.
         - If path is null, return rawJson (fall back to direct property value).
         - Parse and extract: Use `com.jayway.jsonpath.JsonPath.read(jsonString, path)`. This library is already on the classpath (used by `JsonPathConverterBase`).
         - Return the extracted value. Apply `mappingUtils.handleBaseObject()` if result is not null.
         - Wrap in try-catch (JsonPath can throw PathNotFoundException): return null on error, log at DEBUG.
       - `writeField`:
         - JP fields are typically read-only in the generated converters (JsonPath extraction from a JSON column).
         - Log a warning: "JsonPath field write not supported for field: " + field.name().
         - No-op for now. If needed in the future, would require building/modifying JSON and setting back.
  </action>
  <verify>
    - All 3 strategy files exist in `com.etendorx.das.converter.strategy` package.
    - `EntityMappingStrategy` has `@Lazy` annotation on DynamicDTOConverter parameter to break circular dependency.
    - `EntityMappingStrategy.readField` checks `ctx.isVisited()` before recursive conversion.
    - `EntityMappingStrategy.readField` handles both single entity and Collection (one-to-many).
    - `EntityMappingStrategy.writeField` calls `externalIdService.convertExternalToInternalId()`.
    - `JavaMappingStrategy` resolves beans via `applicationContext.getBean(qualifier, DTOReadMapping.class)`.
    - `JavaMappingStrategy.writeField` passes `ctx.getFullDto()` to DTOWriteMapping.
    - `JsonPathStrategy` uses `com.jayway.jsonpath.JsonPath.read()`.
    - All are `@Component` annotated.
  </verify>
  <done>Three complex strategies (EM, JM, JP) implement FieldConversionStrategy with correct behavior: EM handles recursive conversion + cycle detection + ExternalId resolution, JM delegates to Spring-qualified beans, JP extracts values via JsonPath.</done>
</task>

<task type="auto">
  <name>Task 2: Create DynamicDTOConverter orchestrator</name>
  <files>
    modules_core/com.etendorx.das/src/main/java/com/etendorx/das/converter/DynamicDTOConverter.java
  </files>
  <action>
    **Create `DynamicDTOConverter.java`** as `@Component` in package `com.etendorx.das.converter`:

    - Constructor-inject:
      - `DynamicMetadataService` (Phase 1)
      - `AuditServiceInterceptor` (existing `com.etendorx.entities.entities.AuditServiceInterceptor` interface)
      - `EntityManager` (jakarta.persistence)
      - All 6 strategy beans: `DirectMappingStrategy`, `ConstantValueStrategy`, `ComputedMappingStrategy`, `EntityMappingStrategy`, `JavaMappingStrategy`, `JsonPathStrategy`.
    - Use `@Slf4j`.

    - **Strategy map initialization** in constructor:
      ```java
      private final Map<FieldMappingType, FieldConversionStrategy> strategyMap;
      // In constructor:
      this.strategyMap = Map.of(
          FieldMappingType.DIRECT_MAPPING, directMappingStrategy,
          FieldMappingType.CONSTANT_VALUE, constantValueStrategy,
          FieldMappingType.CONSTANT_MAPPING, computedMappingStrategy,
          FieldMappingType.ENTITY_MAPPING, entityMappingStrategy,
          FieldMappingType.JAVA_MAPPING, javaMappingStrategy,
          FieldMappingType.JSON_PATH, jsonPathStrategy
      );
      ```

    - **Method `convertToMap(Object entity, EntityMetadata entityMetadata, List<FieldMetadata> fields, ConversionContext ctx)`**:
      - If entity is null, return null.
      - If ctx is null, create new `ConversionContext()`.
      - Create `Map<String, Object> result = new LinkedHashMap<>()` (LinkedHashMap to preserve field order).
      - Iterate fields (already sorted by line number from metadata service).
      - For each field:
        - Get strategy: `FieldConversionStrategy strategy = strategyMap.get(field.fieldMapping())`.
        - If strategy is null, log warning "No strategy for field mapping type: {}" and skip.
        - Try: `Object value = strategy.readField(entity, field, ctx)`.
        - `result.put(field.name(), value)`.
        - Catch Exception: log error "Error converting field {}: {}", put null in result.
      - Return result.

    - **Convenience overload `convertToMap(Object entity, EntityMetadata entityMetadata)`**:
      - Calls `convertToMap(entity, entityMetadata, entityMetadata.fields(), new ConversionContext())`.

    - **Method `convertToEntity(Map<String, Object> dto, Object entity, EntityMetadata entityMetadata, List<FieldMetadata> fields)`**:
      - If dto is null, throw `ConversionException("DTO map cannot be null")`.
      - If entity is null:
        - Need to instantiate entity. Use `entityMetadata.tableId()` to find the entity class.
        - Query: `entityManager.createQuery("SELECT t.javaClassName FROM ADTable t WHERE t.id = :id", String.class).setParameter("id", entityMetadata.tableId()).getSingleResult()`.
          - Note: ADTable might use a different column name. Check the Table JPA entity. The class is `org.openbravo.model.ad.datamodel.Table` -- it likely has a `getJavaClassName()` method. The JPQL uses the JPA entity name `Table` and property `javaClassName`.
          - Wrap in try-catch. If entity class resolution fails, throw `ConversionException("Cannot determine entity class for table: " + entityMetadata.tableId())`.
        - Instantiate: `entity = Class.forName(javaClassName).getDeclaredConstructor().newInstance()`.
      - Create `ConversionContext ctx = new ConversionContext()`.
      - Set fullDto on context: `ctx.setFullDto(dto)`.
      - **Mandatory field validation (pre-check)**:
        - For each field where `field.mandatory() == true`:
          - If `dto.get(field.name()) == null` and field mapping is not CV/CM (constants don't come from DTO):
            - Throw `ConversionException("Mandatory field missing: " + field.name())`.
      - **Field population**: Iterate fields sorted by line number.
        - For each field:
          - `Object value = dto.get(field.name())`.
          - Get strategy: `FieldConversionStrategy strategy = strategyMap.get(field.fieldMapping())`.
          - If strategy is null, log warning and skip.
          - Try: `strategy.writeField(entity, value, field, ctx)`.
          - Catch ConversionException: re-throw (propagate field-specific errors).
          - Catch Exception: wrap in `ConversionException("Error setting field " + field.name(), e)`.
      - **Audit fields**: After all fields are set:
        - If `entity instanceof BaseRXObject rxObj`:
          - `auditServiceInterceptor.setAuditValues(rxObj)`.
        - This sets client, org, active, createdBy, creationDate, updatedBy, updated automatically from UserContext.
      - Return entity.

    - **Convenience overload `convertToEntity(Map<String, Object> dto, EntityMetadata entityMetadata)`**:
      - Calls `convertToEntity(dto, null, entityMetadata, entityMetadata.fields())`.

    - **Helper method for EM strategy**: `EntityMetadata findEntityMetadataById(String projectionEntityId)`:
      - Iterate all projection names from `metadataService.getAllProjectionNames()`.
      - For each projection name, get the projection, iterate its entities.
      - Return the EntityMetadata whose id matches projectionEntityId.
      - Return null if not found.
      - This is public so EntityMappingStrategy can use it.

    **IMPORTANT NOTES:**
    - The ADTable entity class name in JPQL: check if it's "Table" or "ADTable" -- look at `org.openbravo.model.ad.datamodel.Table` which is the JPA entity. Its entity name should be just the class name. Use `Table` in JPQL.
    - For entity instantiation, cache the className lookup to avoid repeated DB queries. Use a simple ConcurrentHashMap as local cache: `Map<String, String> tableClassNameCache`.
  </action>
  <verify>
    - `DynamicDTOConverter.java` exists in `com.etendorx.das.converter` package.
    - Has `strategyMap` mapping all 6 `FieldMappingType` values to strategies.
    - `convertToMap` iterates fields, delegates to strategies, returns `Map<String, Object>`.
    - `convertToMap` accepts and propagates `ConversionContext` for cycle detection.
    - `convertToEntity` validates mandatory fields before writing.
    - `convertToEntity` calls `auditServiceInterceptor.setAuditValues()` after field population.
    - `convertToEntity` can instantiate new entities via reflection using AD_Table javaClassName.
    - `findEntityMetadataById` provides EM strategy with metadata lookup capability.
    - Class is `@Component` for Spring DI.
  </verify>
  <done>DynamicDTOConverter orchestrator handles bidirectional Entity-Map conversion using all 6 strategies, with mandatory validation, audit field integration, and entity instantiation via AD_Table metadata.</done>
</task>

</tasks>

<verification>
- All 4 files created: 3 strategies + 1 orchestrator.
- DynamicDTOConverter has both `convertToMap` and `convertToEntity` methods.
- All 6 FieldMappingType values have a corresponding strategy in the strategyMap.
- EntityMappingStrategy handles cycle detection via ConversionContext.isVisited().
- EntityMappingStrategy handles both single-entity (many-to-one) and collection (one-to-many) reads.
- EntityMappingStrategy resolves write references via ExternalIdService.
- JavaMappingStrategy resolves read/write beans via ApplicationContext.getBean(qualifier).
- JsonPathStrategy extracts values using com.jayway.jsonpath.JsonPath.read().
- convertToEntity validates mandatory fields and throws ConversionException.
- convertToEntity calls auditServiceInterceptor.setAuditValues() for BaseRXObject instances.
- Circular dependency (EntityMappingStrategy <-> DynamicDTOConverter) resolved via @Lazy.
</verification>

<success_criteria>
- Complete bidirectional converter: Entity -> Map (read) and Map -> Entity (write).
- All 6 field mapping types supported: DM, CV, CM, EM, JM, JP.
- Cycle detection prevents StackOverflowError in recursive EM conversions.
- External ID resolution works for write-path entity references.
- Audit fields automatically populated on write via AuditServiceInterceptor.
- Mandatory field validation returns clear error messages.
- New entity instantiation via AD_Table.javaClassName lookup.
</success_criteria>

<output>
After completion, create `.planning/phases/02-generic-dto-converter/02-02-SUMMARY.md`
</output>
