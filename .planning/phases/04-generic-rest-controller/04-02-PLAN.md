---
phase: 04-generic-rest-controller
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - modules_core/com.etendorx.das/src/main/java/com/etendorx/das/controller/DynamicRestController.java
autonomous: true

must_haves:
  truths:
    - "Client can GET list of entities at /{projectionName}/{externalName} with pagination (default size=20)"
    - "Client can GET single entity by ID at /{projectionName}/{externalName}/{id} returning 200"
    - "Client can POST single entity returning 201 with created entity"
    - "Client can POST batch of entities via JSONArray returning 201 with list"
    - "Client can POST with json_path parameter to extract nested JSON before processing"
    - "Client can PUT entity by ID at /{projectionName}/{externalName}/{id} returning 201"
    - "Non-existent projection returns 404 with descriptive message"
    - "Non-existent entity returns 404 with descriptive message"
    - "Entity with restEndPoint=false returns 404"
    - "Empty/null POST body returns 400"
    - "External IDs in POST/PUT bodies are translated before save"
  artifacts:
    - path: "modules_core/com.etendorx.das/src/main/java/com/etendorx/das/controller/DynamicRestController.java"
      provides: "Single generic REST controller for all dynamic projection endpoints"
      min_lines: 150
      exports: ["findAll", "findById", "create", "update"]
  key_links:
    - from: "DynamicRestController.findAll"
      to: "DynamicRepository.findAll"
      via: "Delegation with projectionName, entityName, filters, pageable"
      pattern: "repository\\.findAll"
    - from: "DynamicRestController.findById"
      to: "DynamicRepository.findById"
      via: "Delegation with id, projectionName, entityName"
      pattern: "repository\\.findById"
    - from: "DynamicRestController.create"
      to: "DynamicRepository.save and DynamicRepository.saveBatch"
      via: "Single vs batch dispatch after json_path parsing"
      pattern: "repository\\.save\\|repository\\.saveBatch"
    - from: "DynamicRestController.update"
      to: "DynamicRepository.update"
      via: "Delegation with dto containing id"
      pattern: "repository\\.update"
    - from: "DynamicRestController (POST/PUT)"
      to: "ExternalIdTranslationService.translateExternalIds"
      via: "Called before repository save/update"
      pattern: "externalIdTranslationService\\.translateExternalIds"
    - from: "DynamicRestController (all methods)"
      to: "DynamicEndpointRegistry.resolveEntityByExternalName"
      via: "Metadata resolution from URL path variables"
      pattern: "endpointRegistry\\.resolveEntityByExternalName"
---

<objective>
Create the DynamicRestController -- a single @RestController with @RequestMapping("/{projectionName}/{entityName}") that handles all CRUD operations for dynamically-served projections.

Purpose: This is the core deliverable of Phase 4 (FR-3). It replaces all per-entity generated REST controllers with a single generic controller that resolves metadata at request time and delegates to DynamicRepository.

Output: DynamicRestController.java replicating the exact behavior of BindedRestController but operating on Map<String,Object> instead of typed DTOs.
</objective>

<execution_context>
@/Users/sebastianbarrozo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sebastianbarrozo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-generic-rest-controller/04-RESEARCH.md
@.planning/phases/04-generic-rest-controller/04-01-SUMMARY.md

Key APIs from prior phases:
- DynamicRepository: findById(id, projName, entityName), findAll(projName, entityName, filters, pageable), save(dto, projName, entityName), update(dto, projName, entityName), saveBatch(dtos, projName, entityName)
- ExternalIdTranslationService (Plan 01): translateExternalIds(dto, entityMeta)
- DynamicEndpointRegistry (Plan 01): resolveEntityByExternalName(projName, extName), isRestEndpoint(projName, extName)
- DynamicMetadataService: getProjection(name) -- projectionName stored in UPPERCASE

Source files to reference:
@libs/com.etendorx.das_core/src/main/java/com/etendorx/entities/mapper/lib/BindedRestController.java
@modules_core/com.etendorx.das/src/main/java/com/etendorx/das/repository/DynamicRepository.java
@modules_core/com.etendorx.das/src/main/java/com/etendorx/das/metadata/models/EntityMetadata.java
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create DynamicRestController with GET endpoints</name>
  <files>modules_core/com.etendorx.das/src/main/java/com/etendorx/das/controller/DynamicRestController.java</files>
  <action>
Create `DynamicRestController` as `@RestController` with `@RequestMapping("/{projectionName}/{entityName}")` in package `com.etendorx.das.controller`.

Add `@Slf4j` annotation.

Constructor-inject:
- `DynamicRepository repository`
- `DynamicEndpointRegistry endpointRegistry`
- `ExternalIdTranslationService externalIdTranslationService`

**Private helper: `resolveEntityMetadata(String projectionName, String entityName)`**
- Returns `EntityMetadata`
- Call `endpointRegistry.resolveEntityByExternalName(projectionName, entityName)`
- If empty, throw `new ResponseStatusException(HttpStatus.NOT_FOUND, "Entity not found: " + entityName + " in projection: " + projectionName)`
- Check `entityMeta.restEndPoint()` -- if false, throw `new ResponseStatusException(HttpStatus.NOT_FOUND, "REST endpoint not enabled for: " + entityName)`
- Return the EntityMetadata

**GET list endpoint: `findAll()`**
```java
@GetMapping
@Operation(security = { @SecurityRequirement(name = "basicScheme") })
public Page<Map<String, Object>> findAll(
        @PathVariable String projectionName,
        @PathVariable String entityName,
        @PageableDefault(size = 20) Pageable pageable,
        @RequestParam(required = false) Map<String, String> allParams) {
```
- Call `resolveEntityMetadata(projectionName, entityName)`
- Remove pagination params from allParams (remove "page", "size", "sort" keys) to get pure filter params
- NOTE: `DynamicRepository.findAll` uses `projectionName` in UPPERCASE for metadata lookup internally. The `resolveEntityByExternalName` in the registry already uppercases. However, DynamicRepository.findAll calls `metadataService.getProjectionEntity(projectionName, entityName)` which expects the projection name and entity NAME (not externalName). So we need to pass the correct values:
  - The projectionName for the repository should be UPPERCASE (e.g., "OBMAP")
  - The entityName for the repository should be the entity's `name()` (not `externalName()`) since that's what `ProjectionMetadata.findEntity()` matches on
  - Get these from the resolved EntityMetadata: use `projectionName.toUpperCase()` and the entity's `name()` field
- Call `repository.findAll(projectionName.toUpperCase(), entityMeta.name(), filters, pageable)`
- Return the Page directly (Spring serializes Page<Map> identically to Page<E>)
- Log at DEBUG level: `"GET /{}/{} - findAll, page={}, size={}"` with projectionName, entityName, pageable page number, pageable page size

**GET by ID endpoint: `findById()`**
```java
@GetMapping("/{id}")
@Operation(security = { @SecurityRequirement(name = "basicScheme") })
public ResponseEntity<Map<String, Object>> findById(
        @PathVariable String projectionName,
        @PathVariable String entityName,
        @PathVariable String id) {
```
- Call `resolveEntityMetadata(projectionName, entityName)`
- Try `repository.findById(id, projectionName.toUpperCase(), entityMeta.name())`
- Catch `jakarta.persistence.EntityNotFoundException` and throw `new ResponseStatusException(HttpStatus.NOT_FOUND, "Record not found")`
- Return `new ResponseEntity<>(result, HttpStatus.OK)`
- Log at DEBUG level: `"GET /{}/{}/{} - findById"` with projectionName, entityName, id
  </action>
  <verify>
File exists. Has @RestController, @RequestMapping("/{projectionName}/{entityName}"), @Slf4j. Has findAll with @GetMapping and @PageableDefault(size=20). Has findById with @GetMapping("/{id}"). Has resolveEntityMetadata private helper that checks restEndPoint flag and throws 404.
  </verify>
  <done>
GET list and GET by ID endpoints exist, resolveEntityMetadata helper validates projection+entity existence and restEndPoint flag, repository delegation uses correct name resolution (uppercase projection, entity name not externalName).
  </done>
</task>

<task type="auto">
  <name>Task 2: Add POST and PUT endpoints with json_path and batch support</name>
  <files>modules_core/com.etendorx.das/src/main/java/com/etendorx/das/controller/DynamicRestController.java</files>
  <action>
Add POST and PUT endpoints to the existing DynamicRestController.

**POST endpoint: `create()`**
```java
@PostMapping
@ResponseStatus(HttpStatus.OK)
@Operation(security = { @SecurityRequirement(name = "basicScheme") })
public ResponseEntity<Object> create(
        @PathVariable String projectionName,
        @PathVariable String entityName,
        @RequestBody String rawEntity,
        @RequestParam(required = false, name = "json_path") String jsonPath) {
```
- Call `resolveEntityMetadata(projectionName, entityName)`
- Validate: if `rawEntity == null || rawEntity.isEmpty()`, throw `new ResponseStatusException(HttpStatus.BAD_REQUEST, "Raw entity cannot be null or empty")`
- Default json_path: `jsonPath = (StringUtils.hasText(jsonPath)) ? jsonPath : "$";` (use `org.springframework.util.StringUtils`)
- Parse JSON using Jayway JsonPath (EXACT pattern from BindedRestController):
  ```java
  Configuration conf = Configuration.defaultConfiguration().addOptions();
  DocumentContext documentContext = JsonPath.using(conf).parse(rawEntity);
  Object rawData = documentContext.read(jsonPath, Object.class);
  ```
- Handle rawData:
  ```java
  ObjectMapper objectMapper = new ObjectMapper();
  if (rawData instanceof JSONArray) {
      // Batch processing
      List<Map<String, Object>> dtoList = new ArrayList<>();
      for (Object rawDatum : ((JSONArray) rawData)) {
          if (rawDatum instanceof Map) {
              @SuppressWarnings("unchecked")
              Map<String, Object> dto = (Map<String, Object>) rawDatum;
              externalIdTranslationService.translateExternalIds(dto, entityMeta);
              dtoList.add(dto);
          } else {
              throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Invalid JSON object in array");
          }
      }
      List<Map<String, Object>> results = repository.saveBatch(dtoList, projectionName.toUpperCase(), entityMeta.name());
      return new ResponseEntity<>(results, HttpStatus.CREATED);
  } else if (rawData instanceof Map) {
      @SuppressWarnings("unchecked")
      Map<String, Object> dto = (Map<String, Object>) rawData;
      externalIdTranslationService.translateExternalIds(dto, entityMeta);
      Map<String, Object> result = repository.save(dto, projectionName.toUpperCase(), entityMeta.name());
      return new ResponseEntity<>(result, HttpStatus.CREATED);
  } else {
      // Fallback: parse the raw entity string directly as a Map
      @SuppressWarnings("unchecked")
      Map<String, Object> dto = objectMapper.readValue(rawEntity, Map.class);
      externalIdTranslationService.translateExternalIds(dto, entityMeta);
      Map<String, Object> result = repository.save(dto, projectionName.toUpperCase(), entityMeta.name());
      return new ResponseEntity<>(result, HttpStatus.CREATED);
  }
  ```
- Wrap entire try/catch: catch `JsonProcessingException` -> 400 "Invalid JSON format", catch `ResponseStatusException` -> rethrow, catch `Exception` -> 400 with message
- Log at DEBUG: `"POST /{}/{} - create (json_path={})"` with projectionName, entityName, jsonPath

**PUT endpoint: `update()`**
```java
@PutMapping("/{id}")
@ResponseStatus(HttpStatus.OK)
@Operation(security = { @SecurityRequirement(name = "basicScheme") })
public ResponseEntity<Map<String, Object>> update(
        @PathVariable String projectionName,
        @PathVariable String entityName,
        @PathVariable String id,
        @RequestBody String rawEntity) {
```
- Call `resolveEntityMetadata(projectionName, entityName)`
- Validate id: if `id == null`, throw `new ResponseStatusException(HttpStatus.BAD_REQUEST, "Id is required")`
- Parse rawEntity as Map:
  ```java
  ObjectMapper objectMapper = new ObjectMapper();
  @SuppressWarnings("unchecked")
  Map<String, Object> dto = objectMapper.readValue(rawEntity, Map.class);
  ```
- Set ID from path: `dto.put("id", id);`
- Translate external IDs: `externalIdTranslationService.translateExternalIds(dto, entityMeta);`
- Call `repository.update(dto, projectionName.toUpperCase(), entityMeta.name())`
- Return `new ResponseEntity<>(result, HttpStatus.CREATED)` (matches BindedRestController.put which returns 201)
- Wrap in try/catch: catch `ResponseStatusException` -> rethrow, catch `Exception` -> 400 with message
- Log at DEBUG: `"PUT /{}/{}/{} - update"` with projectionName, entityName, id

**Required imports to add:**
- `com.fasterxml.jackson.core.JsonProcessingException`
- `com.fasterxml.jackson.databind.ObjectMapper`
- `com.jayway.jsonpath.Configuration`
- `com.jayway.jsonpath.DocumentContext`
- `com.jayway.jsonpath.JsonPath`
- `net.minidev.json.JSONArray`
- `org.springframework.util.StringUtils`
- `java.util.ArrayList`
- `java.util.List`
- `java.util.Map`
  </action>
  <verify>
File has @PostMapping create method with @RequestParam json_path, @RequestBody String rawEntity. Has JSONArray batch detection. Has @PutMapping("/{id}") update method. Both return HttpStatus.CREATED. ExternalIdTranslationService.translateExternalIds called before repository.save/update/saveBatch.
  </verify>
  <done>
POST endpoint handles single entity, batch (JSONArray), and json_path extraction. PUT endpoint sets ID from path variable and updates. Both call ExternalIdTranslationService before save. Response status codes match BindedRestController exactly (201 for POST and PUT).
  </done>
</task>

</tasks>

<verification>
1. DynamicRestController.java exists in `com.etendorx.das.controller`
2. Has `@RequestMapping("/{projectionName}/{entityName}")` for dynamic URL routing
3. GET list uses `@PageableDefault(size = 20)` matching BindedRestController
4. GET by ID returns 200, POST returns 201, PUT returns 201
5. POST handles JSONArray batch, json_path parameter defaulting to "$"
6. resolveEntityMetadata checks restEndPoint flag and returns 404 if false
7. ExternalIdTranslationService.translateExternalIds called in POST and PUT before repository calls
8. Repository calls use `projectionName.toUpperCase()` and `entityMeta.name()` (not externalName)
9. Error handling: 404 for not found, 400 for bad request/JSON, 500 wrapped
</verification>

<success_criteria>
- Single controller at `/{projectionName}/{entityName}` handles GET, GET/{id}, POST, PUT/{id}
- json_path parameter defaults to "$" and supports nested extraction
- Batch POST via JSONArray detection works
- External IDs translated before save/update
- restEndPoint=false returns 404
- Response codes: GET list -> 200 (implicit), GET by ID -> 200, POST -> 201, PUT -> 201
- Non-existent projection/entity -> 404
- Invalid JSON -> 400
</success_criteria>

<output>
After completion, create `.planning/phases/04-generic-rest-controller/04-02-SUMMARY.md`
</output>
