plugins {
    id 'org.springframework.boot' version '3.4.2'
    id 'io.spring.dependency-management' version '1.1.7'
    id 'java'
    id 'java-library'
    id 'groovy'
    id 'jacoco'
    id 'com.etendorx.gradlepluginrx' version '2.1.0'
}

group = 'com.etendorx'
version = "$gradle.ext.version"
java {
  toolchain {
    languageVersion = JavaLanguageVersion.of(17)
  }
}

repositories {
    mavenCentral()
    maven {
        url = "${repositoryUrl}"
        credentials {
            username = "${repositoryUser}"
            password = "${repositoryPassword}"
        }
    }
}

task upgradeRxVersion() {
    final String MAJOR = 'major'
    final String MINOR = 'minor'
    final String PATCH = 'patch'
    doLast {
        def versionType
        if (project.hasProperty('type')){
            versionType = project.getProperty('type')
        } else {
            throw new GradleException("The parameter -Ptype is required")
        }

        if (versionType != MAJOR && versionType != MINOR && versionType != PATCH) {
            throw new GradleException("The parameter value '${versionType}' is not valid, the options should be 'major', 'minor' or 'patch'")
        }

        def version = project.gradle.ext.version.trim().split("\\.")

        if (version.length != 3) {
            throw new GradleException("The version must be in the format major.minor.patch")
        }

        switch (versionType) {
            case MAJOR:
                version[0]++
                version[1] = 0
                version[2] = 0
                break
            case MINOR:
                version[1]++
                version[2] = 0
                break
            case PATCH:
                version[2]++
                break
        }

        def nextVersion = "${version[0]}.${version[1]}.${version[2]}"

        //Rewrite settings.gradle file with new value
        def settingsGradleContent = file('settings.gradle').text
        settingsGradleContent = settingsGradleContent.replaceAll(/gradle.ext.version = '\d+.\d+.\d+'/, "gradle.ext.version = '${nextVersion}'")
        file('settings.gradle').write(settingsGradleContent)
        // Update version in libs/com.etendorx.generate_entities/src/main/resources/version.properties
        def versionPropertiesContent = file('libs/com.etendorx.generate_entities/src/main/resources/version.properties').text
        versionPropertiesContent = versionPropertiesContent.replaceAll(/version=\d+.\d+.\d+/, "version=${nextVersion}")
        file('libs/com.etendorx.generate_entities/src/main/resources/version.properties').write(versionPropertiesContent)
    }
}

test {
    useJUnitPlatform()
}

jacoco {
    toolVersion = "0.8.10"
}

subprojects {
    apply plugin: 'jacoco'
    apply plugin: 'java'

    jacoco {
        toolVersion = "0.8.10"
    }

    task printSourceSets {
        doLast {
            def mainSourceSet = sourceSets.main
            println("Main Java Sources: ${mainSourceSet.java.srcDirs}")
            println("Main Resources: ${mainSourceSet.resources.srcDirs}")
        }
    }
}

task jacocoRootReport(type: JacocoReport) {
    // Configure the task to always run
    outputs.upToDateWhen { false }

    // Find all subprojects that have the JaCoCo plugin applied and collect the necessary information
    def jacocoProjects = subprojects.findAll { subproject ->
        subproject.plugins.hasPlugin('jacoco')
    }

    // Collects the source directories, classes, and execution data of the subprojects with JaCoCo
    additionalSourceDirs = files(jacocoProjects.collect { it.sourceSets.main.allSource.srcDirs }.flatten())
    sourceDirectories = files(jacocoProjects.collect { it.sourceSets.main.java.srcDirs.flatten() })
    classDirectories = files(jacocoProjects.collect { it.sourceSets.main.output })

    // Collect all .exec files from each subproject's build directory
    executionData = files(jacocoProjects.collect {
        fileTree(dir: "${it.buildDir}/jacoco", include: "*.exec")
    })

    reports {
        xml.required = true
        html.required = true
    }
}
